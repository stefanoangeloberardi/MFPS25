% !TEX root = main.tex

\section{The set of infinite lambda-terms}\label{section-infinite-lambda}

In this section we define the set $\LAMBDA$ of infinite $\lambda$-terms given as possibly infinite trees,
the subset $\Reg$ of $\LAMBDA$ consisting of regular trees, which we call 
\emph{circular terms}, 
then the subset $\WTyped$ of well-typed terms of $\LAMBDA$ and a reduction relation for them. In the following sections,
we will prove that the regular well-typed terms of $\LAMBDA$ that satisfy
the global trace condition also satisfy a termination result.

%They will be used to
%give a semantics for finite circular notations for $\lambda$-terms.

%Infinite terms are labeled at most countable binary trees.
%
%, therefore we
%provide a formal definition of at most countable binary trees first.
%, and before them the lists on $\{1,2\}$ and
%some related notions.
%
%\subsection{Lists and Binary Trees}
%
%\begin{definition}(Lists on $\{1,2\}$)
%\begin{enumerate}
%\item
%We denote with $\List(\{1,2\})$ the set of all lists on $\{1,2\}$, just lists for short.
%\item
%If $i_1, \ldots, i_n \in \{1,2\}$, we write $(i_1, \ldots, i_n)$
%for the list with elements $i_1, \ldots, i_n$. 
%\item
%We write $\nil$ for the empty list, or $()$. 
%\item
%If $l=(i_1, \ldots, i_n), m=(j_1, \ldots, j_m) $ are lists
%we define
%$
%l \conc m = (i_1, \ldots, i_n,\ j_1, \ldots, j_m)
%$
%%If $I \subseteq \List(\{1,2\})$
%%we write $l \conc I = \{l \conc m \mid m \in I\}$. 
%\item
%The prefix order $\le$ on lists
%is defined by $l \le m$ if and only if $m = l \conc m'$ for some $m' \in  \List(\{1,2\})$.
%\end{enumerate}
%\end{definition}
%
%Binary trees can be represente represented by sets of lists on $\{1,2\}$.
%
%\begin{definition}(Binary trees)
%\begin{enumerate}
%\item 
%A binary tree, just a tree for short, is any set $T\subseteq \List(\{1,2\})$ 
%of lists including the empty list and closed by prefix: $\nil \in T$ and for all $l, m \in \List(\{1,2\})$
%if $m \in T$ and $l \le m$ then $l \in T$. 
%
%\item
%$\nil$ is called the root of $T$, any $l \in T$ is called a node of
%$T$ and if $l \in T$, then any $l \conc (i) \in T$ is called a child of $l$ in $T$
%of index $i$.
%
%\item
%A node $l$ of $T$ is a leaf of $T$ if $l$ is an maximal element of $T$ w.r.t. the prefix order (i.e.,
%if $l$ has no children). 
%
%\item
%If $T$ is a tree and $l \in T$ we define $T \restr l = \{m \in \List(\{1,2\}) \mid l \conc m \in T\}$.
%$T \restr l$ is a tree and we say that $T \restr l$ is a subtree of $T$ in the node $l$,
%and for each $m \in T \restr l$ we say that $l \conc m$ is the corresponding node in $T$.
%\item
%
%If $l=(i)$ we say that $T \restr l$ is an immediate sub-tree of $T$.
%\item
%A binary tree labeled on a set $L$ is any pair $\setT = (T, \phi)$ with 
%$\phi:T \rightarrow L$. We call $\universe{\setT}=T$ the set of nodes of $\setT$.
%For all $l \in T$ we call $\Label(\setT,l) = \phi(l)$ the label of $l$ in $\setT$.
%\item
%We define $\setT \restr l = (T \restr l, \phi_l)$ and $\phi_l(m) = l \conc m$. 
%We call any $\setT \restr l$ a labeled subtree of $\setT$
%in the node $l$, an immediate sub-tree if $l=(i)$. 
%\end{enumerate}
%\end{definition}

%Remark that the labeling of a node $m \in \universe{( \setT \restr l )}$ 
%is the same label of the corresponding node $l \conc m$ of $\universe{\setT}$.
% 
%Let $n = 0, 1, 2$. We define an operation $l(\setT_1, \ldots, \setT_n)$
%combining labeled trees which we will use to produce tree notation. 
%Assume $\setT_1, \ldots,\setT_n$ are trees labeled on $L$ and $l \in L$.
%Then we define $$\setT = l(\setT_1, \ldots, \setT_n)$$ 
%as the unique tree $\setT$ labeled on $L$ with the root labeled $l$ and with:
%$\setT \restr (i) = \setT_i$ for all $1 \le i \le n$.

\subsection{Types, terms and contexts}
We define the syntax of our infinite $\lambda$-calculus. 
First we introduce the types, 
and then give the set $\LAMBDA$ of terms and the contexts for $\LAMBDA$.

\begin{definition}[Types]
  We fix a countable set $\{\alpha,\beta,\ldots\}$ of type variables
  \footnote{Type variables play a minor role in this paper.
  They can used to provide some examples for our terms.
  %in Section~\ref{section-circular-system-CTlambda}.
  }. 
\begin{enumerate}
\item  
  The \emph{simple types} (or \emph{types} for short), denoted by $T,A,B,\ldots$,
  are inductively defined by: 
  $\N$ of natural numbers, type variables, and $A \rightarrow B$, provided $A$ and $B$ are types.
  We write $\Type$ for the set of simple types.
\item
  We abbreviate $A_1 \rightarrow (A_2 \rightarrow \cdots (A_n \rightarrow B))$
  with $A_1,A_2,\ldots,A_n \rightarrow B$ and 
  with $\vec{A} \rightarrow B$ when $\vec{A} = A_1, \ldots, A_n$.
  We write $A^n \rightarrow B$ when $A_1,\ldots,A_n$ are the same type $A$. 
\end{enumerate}
\end{definition}

Terms of our system are possibly infinite binary trees, with each node labeled by 
some connective on $\lambda$-terms having arity (number of children) $0$, $1$, or $2$.

\begin{definition}[Variables and terms]
We fix a countable set $\{x,y,\ldots\}$ of variable names. 
\begin{enumerate}
\item
A \emph{variable} $x^T$ is a variable name $x$ with a type superscript $T$. 
\item  
A \emph{term} is a possibly infinite labeled binary tree, denoted by $t,u,v,\ldots$, with labels 
$x^T$, $\lambda x^T$, $\ap$, $0$, $\Succ$, and $\cond$, such that:
\begin{enumerate}
\item 
a node labeled $x^T$ or $0$ has \emph{no} children;

\item
a node labeled $\lambda x^T$ or $\Succ$ has a \emph{unique} child;

\item
a node labeled $\ap$ or $\cond$ has \emph{two} children.
\end{enumerate}  
\item
The set of all terms is denoted by $\LAMBDA$.
\end{enumerate}

We say that $u$ is a subterm of $t$ if $u$ is a sub-tree of $t$,
with labeling the restriction of the labeling of $t$ to the nodes of $u$.
We say that $u$ is an \emph{immediate} subterm if $u$ is an immediate sub-tree.
\end{definition}

%%%%%%%%%%%%%%%%%
%% PERHAPS THE REMARKS ABOUT ISOMORPHISMS ARE PEDANTIC
%%%%%%%%%%%%%%%%%
%We define a tree isomorphism between two possibly infinite trees by
%a bijection on nodes that preserves root, edges, 
%and the children-order of corresponding parent nodes.
%We write $t \sim u$ and read \quotationMarks{$t$ and $u$ are isomorphic terms}
%if and only if there is some label-preserving tree isomorphism between $t$ and $u$.
%In general, we do not identify two isomorphic terms because 
%we need to distinguish different occurrences
%of redexes (defined later), which may have the same shape in an infinite term. 
%%%%%%%%%%%%%%%%%
%We often write a term by its (possibly infinite) one-line denotation,
%namely, a term with the root labeled $x^T$, $0$,
%$\Succ$ with a child $t$,
%$\lambda x^T$ with a child $t$,
%$\ap$ with (left and right) children $t$ and $u$,
%$\cond$ with children $t$ and $u$ is denoted by
%$x^T$, $0$, $\Succ(t)$, $\lambda x^T.t$, $\ap(t,u)$, $\cond(t,u)$, respectively. 
%This denotation is unique up to term isomorphism.
%Conversely, 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Each $v \in \LAMBDA$ is in one of the forms:
$x^T, 0, \lambda x^T.t$, $\ap(t,u)$, $\Succ(t)$, $\cond(t,u)$ for some possibly infinite
$t, u \in \LAMBDA$.
As usual, we abbreviate $\ap(t,u)$ with $t(u)$.
We often omit type superscripts of variables when they are clear from the context. 
Now we define the regular terms of $\LAMBDA$.

%11:55 22/04/2024

\begin{definition}[Regular terms of $\LAMBDA$]
%\mbox{}
\begin{enumerate}

\item
We write $\SubTerm(t) = \{\,u \mid \mbox{$u$ subterm of $t$}\,\}$ %/\!\sim$ 
for the set of subterms of $t$. %, with isomorphic terms identified. 

\item
$\Reg$ is the set of terms $t \in \LAMBDA$ such that $\SubTerm(t)$ is finite.
%(up to term isomorphism there are only finitely many subterms of $t$).
We call the terms of $\Reg$ the \emph{regular terms}.

%\item
%We write $\Tree(t)$ for the tree of all chains
%$(t_1, \ldots, t_n)$ with $t_1=t$ and weakly increasing by $\sqsubset_1$: 
% for all $(i+1) \le n$ we have $t_{i+1}=t_i$ or $t_{i+1} \sqsubset_1 t_i$.

\item
  When $t = \Succ^n(0)$, namely $\Succ(\cdots \Succ(0))$ ($n$-times of $\Succ$),
  for some natural number $n \in \Nat$, we say that $t$ is a numeral.
  $\Num$ is the set of numerals.
  %By abuse of notation, we abbreviate $\Succ^n(0)$ by $n$.
\end{enumerate}
 
\end{definition}

%We use two different names for the operation $\ap(t,u)$: 
%we call it $\ap$ when $u$ is not a variable and $\apvar$ when $u$ is a variable. 

The set $\Num$ is the representation of the set $\Nat$ of natural numbers inside $\LAMBDA$. 

\begin{example}
\label{example-regular-infinite}
An example of a regular term and an infinite tree: let $t$ be the term defined by %the isomorphism
$t = \cond(0,\lambda x^N.t(x))$. 
Then $\SubTerm(t) = \{t,0,\lambda x.t(x), t(x), x\}$. %, up to term isomorphism.
Thus, $t$ is a regular term.
However, $t$ is an infinite tree (it includes a proper subtree %isomorphic 
equal to itself). 
\end{example}

%Regular terms have \emph{finitely many} distinct variables, 
%even if each variable can occur infinitely many times in the tree,
%like $x$ in $t$ above. Through renaming of bound variable a regular term 
%can be $\alpha$-equivalent to a non-regular infinite term 
%with infinitely many distinct bound variables. In the example above we can
%rename each occurrence of $\lambda x.t(x)$ in the infinite tree 
%to $\lambda x'.t(x')$, $\lambda x''.t(x'')$, \ldots, the infinite term $t'$ we obtain
%in this way has infinitely many subterms $x', x'', \ldots$, therefore it is not
%regular, yet is it $\alpha$-equivalent to the regular term $t$.

The binder relation is defined as for finite $\lambda$-calculus.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% I removed this quotation because I could not make it working Stefano 08/07/2025
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
(\cite{Barendregt1984}, \S 2.1.6 p. 24). 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{definition}[Binding relation]
\label{definition-binder-relation}
Let $t$ be a term.
\begin{enumerate}
\item
An occurrence of a variable $x^T$ in $t$ is any node of $t$ labeled $x^T$.
\item
An occurrence of a variable $x^T$ in $t$ is said to be \emph{free} if there is no node labeled $\lambda x^T$
in the path from the root of $t$ to the occurrence. 
$\FV(t)$ is the set of variables having at least one free occurrence in $t$.
\item
An occurrence of $x^T$ in $t$ is said to be \emph{bound} if it is not free. If an occurrence is bound, then
the node labeled $\lambda x^T$ closest to the occurrence is called the \emph{binder} of
the occurrence.
The binding relation is a binary relation from a node with a 
binder $\lambda x^T.$  to a node  which is an occurence of $x^T$ bound by it. 
\end{enumerate}
\end{definition}

We also introduce an $\alpha$-conversion relation to avoid variable capture
during substitution. With respect to the $\alpha$-conversion
relation for finite $\lambda$-terms
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% I removed this quotation because I could not make it working Stefano 08/07/2025
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
(\cite{Barendregt1984}, \S 2.1.11 p.26),
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%we add the requirement that equal/different bound variables are renamed by equal bound variables. 
%In this way, 
we only consider $\alpha$-conversions 
preserving the regularity of a term.

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%FIRST VERSION%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\begin{definition}[Equality-preserving $\alpha$-conversion]
%\label{definition-alpha-conversion}
%Let $t$ and $u$ be terms.
%\begin{enumerate}
%\item
%$\phi:t \rightarrow u$ is an \emph{$\alpha$-conversion map} if  
%$\phi$ is a tree isomorphism between $t$ and $u$ such that:
%\begin{enumerate}
%\item
%$\phi$ preserves all labels except for $\lambda x^T$ and $x^T$;
%\item 
%$\phi$ preserves all labels $x^T$
%on a free variable occurrence, and the fact that it is free;
%\item
%$\phi$ sends each label $\lambda x^T$ to some label $\lambda y^T$, each label $x^T$
%on a bound variable to some label $y^T$ on a bound variable, and preserves the
%binding relation. 
%\end{enumerate}
%
%\item
%  An $\alpha$-conversion map $\phi$ is \emph{equality-preserving} 
%  if $\phi$ preserves the equalities and disequalities of labels. 
%\item
%We write $t \sim_\alpha u$ if there is some \emph{equality-preserving} 
%$\alpha$-conversion $\phi:v \rightarrow w$ such that $u$ is obtained from $t$
%by replacing $v$ with $w$.
%\end{enumerate}
%\end{definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{definition}[Regularity-preserving $\alpha$-conversion]
\label{definition-alpha-conversion}
Let $t$ and $u$ be terms.
\begin{enumerate}
\item
$\Phi:t \rightarrow u$ is an \emph{$\alpha$-conversion map} if  
for some \emph{injection} $\phi$ on variables,
$\Phi$ is a tree isomorphism between $t$ and $u$ such that:
$\Phi$ is the identity on all labels except for $\lambda x^T$ and a bound $x^T$
which are mapped to $\lambda \phi(x^T)$ and to $\phi(x^T)$

\item
We write $t \sim_\alpha u$ for the smallest congruence relation (i.e.,
equivalence relation compatible with term formation)
such that $\Phi:t \rightarrow u$ for some $\alpha$-conversion map $\Phi$
implies $t \sim_\alpha u$.
\end{enumerate}
\end{definition}
% Equality-preserving condition 
%implies that (a) if some occurrence of $\lambda x^T$ is sent to $\lambda y^T$, then
%all other occurrences of $\lambda x^T$ must be sent to $\lambda y^T$,
%and (b) different $\lambda$-labels (those of the form $\lambda x^T$) cannot be sent to the same label.
%$\sim_\alpha$ is an equivalence relation (the symmetricity is shown by (b)),
%The last clause is required for having 
For instance we have $\Phi:\lambda x.x \rightarrow \lambda y.y$ where
$\Phi$ switches all bound occurrences of $x$ and of $y$.
By definition, $\sim_\alpha$ is a congruence relation, for example, we have
$t = (\lambda x.x)(\lambda y.y) \sim_\alpha (\lambda x.x)(\lambda x.x) = u$ 
by replacing the subterm $\lambda y.y$ of $t$ with $\lambda x.x \sim_\alpha \lambda y.y$.
Any $\alpha$-conversion map $\Phi$, being defined through an injection
on binders and bound variables, is a bijection on sub-terms, therefore
preserves regularity. 
Thus, $t \sim_\alpha u$ and $t$ is regular then $u$ is regular: the proof is
by induction on the definition of $\sim_\alpha$. For instance, if
moving from $t$ to $u$ we replace some sub-term $v$ with some $\Phi:v \rightarrow w$,
then in $u$, at most, we have all sub-terms of $t$ and we add all sub-terms of $w$.

We avoid using the generalmost notion of $\alpha$-conversion, instead, because it does
not preserve regularity. For instance,
$f = \lambda x^\N.\cond(x,f0)$ is $\alpha$-convertible to 
a non-regular term 
$\lambda x_1^\N.\cond(x_1,\lambda x_2^\N.\cond(x_2,(\lambda x_3^\N.\cond(...))0)0)$,
with infinitely many distinguished bound variables $x_1,x_2,x_3,\ldots$. 

In order to define typing of our terms, we first define contexts and typing judgments.

%13:32 22/04/2024
%11:17 29/04/2024

\begin{definition}[Contexts and typing jugdments for $\LAMBDA$]
\label{definition-context-lambda}
\begin{enumerate}

\item
\label{definition-context-lambda-01}
A \emph{context}, denoted by $\Gamma, \Delta$, is a finite list
$(x_1^{A_1}:A_1,\ldots,x_n^{A_n}:A_n)$ of type assignments to distinct
variables.
The set $\FV(\Gamma)$ is the set of variables in a context $\Gamma$.
We write $\Ctxt$ for the set of contexts.
%% A  context of $\LAMBDA$ is any finite list 
%% $\Gamma = ({x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_n)$ 
%% of \emph{distinct variables}, for some $A_1, \ldots, A_n \in \Type$. 
%% We denote the empty context with $\nil$. 
%We write $\Ctxt$ for the set of all contexts.

%% \item
%% \label{definition-context-lambda-05}
%We say that $\Gamma$ is a context for $t \in \LAMBDA$ and we write $\Gamma 
%\vdash t$ if $\FV(t) \subseteq \FV(\Gamma)$.

%\item
%\label{definition-context-lambda-03}
%A sequent is a pair $(\Gamma, A)$ of a context $\Gamma$ and a type $A$.
%%, which we write as $\Gamma \vdash A$. 
%We write $\Judg = \Ctxt \times \Type$ for the set of all sequents.

\item
\label{definition-context-lambda-07}
The context $\Gamma\setminus\{x^T:T\}$ is obtained
by removing $x^T:T$ from $\Gamma$ if the type assignment presents, 
otherwise it is $\Gamma$.

\item
\label{definition-context-lambda-08}
  Let $\Gamma$ and $\Gamma'$ be $({x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_n)$ and $({x'_1}^{A'_1} :  A'_1, 	  \ldots,    {x'_{n'}}^{A'_{n'}} : A'_{n'})$, respectively. 
We write $\phi:\Gamma \rightarrow \Gamma'$ if and only if
$\phi$ is an injection from $\{1,\ldots,n\}$ to $\{1,\ldots,n'\}$
and we have $x_{i}=x'_{\phi(i)}$ and $A_{i}=A'_{\phi(i)}$ for all $i \in \hbox{dom}(\phi)$. 

\item 
\label{definition-context-lambda-04}
A \emph{typing judgment} is a triple $(\Gamma,t,A) \in \Ctxt \times \LAMBDA \times \Type$,
which is written in the form $\Gamma \vdash t:A$.
When $\Gamma$ is the empty context $\nil$, we abbreviate $\nil\vdash t:A$ with $\vdash t:A$. 
We write $\Judg$ for the set of all typing judgments.

%\item
%\label{definition-context-lambda-06}
%If $\Gamma = ({x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_n)$ ,
%$\Gamma' = (x'_1:A'_1, \ldots, x'_n:A'_{n'})$ are contexts of $\LAMBDA$, then we write $\Gamma \ \subseteqsim \ \Gamma'$ \ if for all $(x^A:A)$:  \ 
%$(x^A:A) \in \Gamma  \ \Rightarrow  \  (x^A:A)\in\Gamma'$.
%
%\begin{enumerate}
%\item
%$\Gamma \ \subseteqsim \ \Gamma'$ \ if for all $(x^A:A)$:  \ 
%$(x^A:A) \in \Gamma  \ \Rightarrow  \  (x^A:A)\in\Gamma'$
%
%\item
%$\Gamma \sim \Gamma'$  \  if for all $(x^A:A)$:  \ 
%$(x^A:A) \in \Gamma  \ \Leftrightarrow  \  (x^A:A)\in\Gamma'$
%\end{enumerate}

\end{enumerate}
%As usual, we informally write a sequent $(\Gamma, A)$ for $t$ in the form $\Gamma \vdash t:A$.
\end{definition}

We have $\FV(\Gamma) \subseteq \FV(\Gamma')$ if and only if 
there is a unique $\phi:\Gamma \rightarrow \Gamma'$, which can be a permutation. 
Note that a type assignment $x^T:T$ is \emph{redundant},
since each variable already has its type superscript.
We write $x^T:T$ (or simply $x:T$)
for uniformity with the notation $x:T$ in use in type theory.

%We have  $\Gamma \sim \Gamma'$ if and only if  $\Gamma \subseteqsim \Gamma'$
%and  $\Gamma \supseteqsim \Gamma'$ if and only if $\Gamma$, $\Gamma'$ are permutation
%each other if and only if the map $\phi$ above is a bijection. We do not identify two contexts
%which are one a permutation of the other, therefore we will need a rule to move from one to the other.


%12:38 17/04/2024
%15:37 17/04/2024

%From the context for a term we can define a context for each subterm of the term.


%21:26 19/04/2024

%\begin{definition}[Inherited Contexts of $\LAMBDA$]
%
%Given any context $\Gamma$, any $t \in \Lambda$ and any subterm chain 
%$\pi = (t_1, \ldots, t_n) \in \Tree(t)$, we define a unique inherited context for $t_n$ in $\pi$.
%The inherited context is obtained by repeatedly adding $x^T:T$ to the context whenever we
%cross a term $t_i = \lambda x^T.u_i$, while simultaneously removing $x^T:T$ from the previous
%context, if it was there.
%%08:00 20/04/024
%
%\begin{enumerate}
%
%\item
%$t$ has inherited context $\Gamma$.
%
%\item
%Any binder on $x$ subtracts the variable $x$ from the context of its \emph{last} argument:
%if $t = \lambda x^T.u, \cond(f,g)$ has inherited context $\Delta$, 
%then $u$ and $g$ have context $\Delta \setminus \{x^T:T\}, x^T$, 
%while $f$ has  inherited context $\Delta$.
%
%\item
%In any other case the context of a term and of the immediate subterm are the same:
%ff $t=\Succ(u), f(a)$ have inherited context $\Delta$,
% then $u,f,a$ have  inherited context $\Delta$.
%\end{enumerate}
%We abbreviate \emph{`` inherited context from $\Gamma$''} with \emph{context}
%when $\Gamma$ is fixed.
%\end{definition}



%The scope of the binder $\lambda x^T.t$ is $t$.
%The scope of the binder $\cond(f,g)$ is $g$ ($f$ is \emph{not} in the scope of $\cond(f,g)$).

Assume that $\FV(t)$, $\FV(u)$ are finite. 
We define $t[u/x]$ by substituting $u$ for all free occurrences of $x$ in $t$, 
by first replacing $t$ with some $t' \sim_\alpha t$
in order to avoid that free occurrences in $u$ become bound after substitution. 
If $\FV(u)$ is finite, we can always
rename all bound variables in $t$ in order to make them different from the variables
in $\FV(u)$. If $\FV(t)$, $\FV(u)$ are finite then is $\FV(t[u/x])$ finite.

The use of $\sim_\alpha$ for substitution is relevant for the theory but not
for computation. Indeed,
substitution of a closed term $u$ requires no renaming, and  in order to use 
infinite $\lambda$-terms as a programming language we only need computations 
involving substitution of closed terms. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%IN THE CONGRESS VERSION I WOULD NOT INCLUDE THE
% EQUATIONS FOR SUBSTITUTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%In order to define the capture avoiding substitution
%under the assumption of not having implicit $\alpha$-equivalence, 
%we implicitly fix a well-order on variables
%and define the simultaneous substitution,
%written $t[u_1/x_1,\ldots,u_n/x_n]$ or $t[\vec{u}/{\vec{x}}]$,
%namely it satisfies the following:
%\begin{itemize}
%\item
%  $x_i[u_1/x_1,\ldots,u_n/x_n] = u_i$ and $y[\vec{u}/\vec{x}] = y$, where $y\not\in\vec{x}$. 
%\item
%  $(f(a))[\vec{u}/\vec{x}] = f[\vec{u}/\vec{x}](a[\vec{u}/\vec{x}])$.
%\item
%  $(\lambda z^T.b)[\vec{u}/\vec{x}] =
%  \left\{
%  \begin{array}{ll}
%    \lambda z^T.(b[\Restrict{(\vec{u}/\vec{x})}{\overline{z}}]),
%    &
%    \text{if $z \not\in \FV(\vec{u})$},
%    \\
%    \lambda z'^T.(b[\Restrict{(\vec{u}/\vec{x})}{\overline{z}},z'/z]),
%    &
%    \text{otherwise},
%  \end{array}
%  \right.$
%  \\
%  where
%  $\Restrict{(\vec{u}/\vec{x})}{\overline{z}}$ is the one obtained by removing $u/z$ (for some $u$) from $\vec{u}/\vec{x}$,
%  and 
%  $z'$ is the least variable (with respect to the well-order)
%  such that $z' \not\in \FV(b,\vec{u})$.
%\item
%  $0[\vec{u}/\vec{x}] = 0$.
%\item
%  $\Succ(t)[\vec{u}/\vec{x}] = \Succ(t[\vec{u}/\vec{x}])$.
%\item
%  $\cond(f,g)[\vec{u}/\vec{x}] = \cond(f[\vec{u}/\vec{x}],g[\vec{u}/\vec{x}])$.
%\end{itemize}
%
%Formally we define the substitution as follows.
%\begin{definition}[Substitution for terms of $\LAMBDA$]
%  A set $\theta=\{u_1/x_1,\ldots,u_n/x_n\}$ is called a {\em substitution}
%  if $x_1,\ldots,x_n$ are pairwise distinct variables.
%  It is called {\em renaming} if $u_1,\ldots,u_n$ are pairwise distinct variables. 
%  We define $\theta(y)$ by $u_i$ if $y=x_i$, and by $y$ otherwise.
%  We write $\theta,\theta'$ if $\theta\cup\theta'$ is a substitution.   
%  The substitution $\Restrict{\theta}{\overline{x}}$ is defined 
%  as the one obtained by removing $u/x$ (for some $u$) from $\theta$. 
%  
%  Let $t$ be a term of $\LAMBDA$, which is the labeled tree $(T_t,\phi_t)$,
%  and $\theta$ be $\{u_1/x_1,\ldots,u_n/x_n\}$, where each $u_i$ is $(T_{u_i},\phi_{u_i})$. 
%  Then the term $t[\theta]$ is $(T,\phi)$, where 
%  $T = T_t \cup \{l\conc m \mid \text{$\phi_t(l) = x_i \in \FV(t)$ and $m\in T_{u_i} $}\}$.
%  For each $l\conc m$ in the latter part, $\phi(l\conc m) = \phi_{u_i}(m)$.  
%  For $l\in T_t$, we inductively define $\phi(l)$ and
%  $\theta_l$ (such that $\theta_l = \theta',\theta_{ren}$, where $\theta'\subseteq \theta$ and $\theta_{ren}$ is a renaming) as follows. 
%  \begin{itemize}
%  \item
%    $\theta_{\nil} = \theta$.
%  \item
%    If $\phi_t(l) = y^T \not\in\FV(t)$, then $\phi(l) = \theta_l(y^T)$.
%  \item
%    If $\phi_t(l) = 0$, then $\phi(l) = 0$. 
%  \item    
%    If $\phi_t(l) = \Succ$, then $\phi(l) = \Succ$ and $\theta_{l\conc (1)} = \theta_l$. 
%  \item    
%    If $\phi_t(l) \in \{\ap,\cond\}$, then $\phi(l) = \phi_t(l)$
%    and $\theta_{l\conc (1)} = \theta_{l\conc(2)} = \theta_l$.
%  \item
%    If $\phi_t(l) = \lambda z^T.$ and $z\not\in\FV(\vec{u})$,
%    then $\phi(l) = \lambda z^T.$ and $\theta_{l\conc(1)} = \Restrict{(\theta_l)}{\overline{z}}$. 
%  \item
%    If $\phi_t(l) = \lambda z^T.$ and $z\in\FV(\vec{u})$,
%    then $\phi(l) = \lambda z'^T.$ and $\theta_{l\conc(1)} = \Restrict{(\theta_l)}{\overline{z}},z'/z$, where $z'$ is the least variable such that $z' \not\in \FV(t\restr l\conc(1),\vec{u})$.
%  \end{itemize}
%  We often abbreviate $t[\{u_1/x_1,\ldots,u_n/x_n\}]$ by $t[u_1/x_1,\ldots,u_n/x_n]$.
%  For a context $\Gamma = (x_1:A_1,\ldots,x_n:A_n)$ and a renaming $\theta$,
%  we write $\Gamma[\theta]$ for $(\theta(x_1):A_1,\ldots,\theta(x_n):A_n)$ if it is a context. 
%\end{definition}
%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%
% 14:47 01/04/2025
%
% Apparently, the Substitution Lemma is never used while
% proving the results of our MFPS 25 paper.
% So I crossed it out
%%%%%%%%%%%%%%%%
%
%We have the following Substitution Lemma. 
%
%\begin{lemma}[Substitution lemma]\label{lem:subst}
%Assume $t, u \in \LAMBDA$ and $x$, $y$ are variables. 
%If $x\not\in\FV(v)$ then $t[u/x][v/y]$ and $ t[v/y][u[v/y]/x]$ are 
%$\alpha$-equivalent. 
%\end{lemma}
%%%%%%%%%%%%%%%%

\subsection{Typing rules}
We define typing rules for terms of $\LAMBDA$.
%and the subset $\WTyped$ of well-typed terms.
%The typing rules are similar to those of the usual simply typed $\lambda$-calculi
%with natural number types (though ours are for possibly infinite terms),
%except for the rules for $\cond$ and $\ap$. 
The typing rule for $\cond(a,f)$ reflects the computational meaning of $\cond$,
which is a function $\N\rightarrow A$ that returns $a$ for the input $0$,
and returns $f(t)$ for an input $\Suc{t}$. 
The typing rule for $\ap(t,u)$ is split into two sub-rules,
$\apvar$ and $\apnotvar$ depending on whether $u$ is a variable or not. 
This is for defining the trace relation and the global trace condition for $\LAMBDA$, 
which will appear later. 
%We will explain the rules for $\ap$ in more detail after the definition of GTC. 

%% [The following part will be put in the later section]
%% %the conditional binder $\cond$, and for 
%% the \emph{typing rule for applications} $t(u)$, which we split the rule into two sub-rules, $\apvar$
%% and $\apnotvar$, according to whether $u$ is a variable or is not a variable.
%% %$\apvar$ corresponds to an $\eta$-expansion and it introduces a global variable name $x^T$
%% %for the first argument of $t$. 
%% %As we said, 
%% We need to consider apart the case $t(x)$ of application of $t$ to a variable
%% $x$, because in this case we will also check, using the global trace condition, 
%% whether the first argument of $t$ is infinitely decreasing in any infinite 
%% computation. If this is the case, then no infinite computation exists. $\apvar$ is like 
%% a mark \quotationMarks{to be observed} for the argument $x$ of $t(x)$,
%% it helps to automatically discover a part of the terminating functions.

%% Remark that we introduced a unique \emph{term notation $\ap$} for application: 
%% we write $\ap(t,u)$ no matter if $u$ is a variable or not, while we split 
%% the typing rule for $\ap$ into two sub-cases. 


\begin{definition}[Typing rules of $\LAMBDA$]
%Assume $\Gamma = {x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_1$ is a context. 
%$\Delta = y_1:B_1, \ldots, y_n:B_m$ are sequents of length $n$, $m$ respectively. Suppose
%$f:\{1, \ldots, n\} \rightarrow \{1, \ldots, m\}$ is any injection, compatible with types
%in $\Gamma$, $\Delta$: we assume $A_i = B_{f(i)}$ for all $1 \le i \le n$.
We list the typing rules for $\LAMBDA$.
\begin{enumerate}
\item
$\weak$-rule (for Weakening + Exchange).
If $\Gamma \vdash t:T$ and $\FV(\Gamma) \subseteq \FV(\Gamma')$,
then $\Gamma' \vdash t : T$.

\item
$\var$-rule.
If $x^A \in \FV(\Gamma)$, then $\Gamma \vdash x^A:A$.

\item
$\lambda$-rule.
If $\Gamma\setminus \{x^A:A\}, x^A:A \vdash b: B$,
then $ \Gamma \vdash \lambda x^A.b :A \rightarrow B$.

\item
$\apvar$-rule.
If $\Gamma \vdash f: A \rightarrow B$, then $\Gamma \vdash f(x^A) :  B$,
provided  $x^A \in \FV(\Gamma)$.

\item
$\apnotvar$-rule.
If $\Gamma \vdash f:A \rightarrow B$ and $\Gamma \vdash a:A$
then $\Gamma \vdash f(a) : B$, provided $a$ is \emph{not} a variable. 

\item
$0$-rule.
$\Gamma \vdash 0: \N$ holds without any premises. 

\item
$\Succ$-rule.
If $\Gamma \vdash t:\N$ then $\Gamma \vdash \Succ (t):\N$.

\item
$\cond$-rule.
If $\Gamma \vdash  a :A$ and  $\Gamma \vdash f : \N \rightarrow A$ 
then $\Gamma \vdash \cond(a,f) : \N \rightarrow A$.
\end{enumerate}

%We have a single structural rule  $\struct_f$, which can be used for:
% weakening, variable permutation and variable renaming. 
%We have a single structural rule $\weak$ for extending a context 
%$\Gamma$ to a context 
%$\Gamma' \supseteqsim \Gamma$. When $\Gamma' \sim \Gamma$ (when 
%$\Gamma'$, $\Gamma$ are permutation each other), 
%the rule $\weak$ can be used for variable permutation.
%%Variable renaming for a term $t[\vec{x}]$ can be obtained by writing 
%%$(\lambda \vec{x}.t[\vec{x}])(\vec{x'})$. 

%Therefore we do not assume having a primitive rule for renaming. 
%The lack of a renaming rule is a 
%\emph{difference with the circular syntax for inductive \underline{proofs}}.
%
%The reason of not having implicit $\alpha$-conversion mentioned in the previous section 
%comes from this assumption. 
%For example, if we identify the $\alpha$-equivalent terms $\lambda x^A.x$ and $\lambda z^A.z$,
%the left derivation is a correct proof, but the right one is not ($(z:A,z:A)$ is not a context).
%That is, the proof structure does not closed under identity of the $\alpha$-equivalence. 
%\begin{center}
%  $\infer{
%    z:A \vdash \lambda x^A.x:A\to A
%  }{
%    \infer{
%      z:A, x:A \vdash x:A
%    }{}
%  }$
%  \qquad
%  $\infer{
%    z:A \vdash \lambda z^A.z:A\to A
%  }{
%    \infer{
%      z:A, z:A \vdash z:A
%    }{}
%  }$  
%\end{center}
%The provability of sequents is closed under the variable renaming and the $\alpha$-equivalence.
%We will discuss this point later. 

%11:56 29/04/2024

An instance of a typing rule $r$ is a list $(J_1,\ldots,J_p,J)$ of typing judgments $(p=0,1,2)$,
where \emph{``$J$ is obtained from $J_1, \ldots, J_p$ by applying the rule $r$''}, and we draw it as:
\raisebox{-5pt}{\scalebox{0.7}{
  $\infer[r]{
    J
  }{
    J_1
    &
    \cdots
    &
    J_p
  }$}}.
The judgments $J_1,\ldots,J_p$ are called the \emph{premises} of $r$,
and $J$ is called the \emph{conclusion} of $r$. 


The set $\Rule$ of rule instances for $\LAMBDA$ is defined by
\[
\Rule = 
\{\,r \in \Judg \cup \Judg^2 \cup \Judg^3 \mid \mbox{$r$ is an instance of some rule for $\LAMBDA$}\,\}.
\]
\end{definition}

When $x^A \not \in \FV(\Gamma)$, the $\lambda$-rule becomes:
if $\Gamma, x^A:A \vdash t: B$
then $ \Gamma  \vdash \lambda x^A.t :A \rightarrow B$.

We have $\weak$-rule as a primitive rule, even if $\weak$ could be
conditionally derived from the other rules. The reason is that it is simpler
to write examples of regular terms when we use typing rules with $\weak$
(see Example~\ref{example-sum-first} below).

%Indeed, we use $\weak$-rule to remove bound variables no more in use when 
%whenever we unfold a fixed point definition. Without $\weak$-rule, we would be 
%forced to introduce more and more fresh names for bound variables in order to 
%prevent variable capture. Eventually we would add infinitely many fresh variable 
%names, and this would destroy the regularity of the term.

%A last remark. In the $\weak$-rule, from the condition 
%$\FV(\Gamma) \subseteq \FV(\Gamma')$
%we can recover a unique map $\phi$ such that $\phi:\Gamma \rightarrow \Gamma'$.
%We will use the information in $\phi$ to state the global trace condition for terms
%of $\LAMBDA$.

We say that two rule instances are equal if they have the same list of judgments. 
Any rule instance $r$ different from $\weak$ can be uniquely recovered from 
the conclusion $\Gamma \vdash t:A$ of $r$.

\begin{proposition}(Rules and subterms)\label{proposition-rules-subterms}
Assume $r, r' \in \Rule$ are not instances of the $\weak$-rule 
and have the same conclusion $\Gamma \vdash t:A$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% WE CANNO INCLUDE THE weak RULE
% THE ASSUMPTIONS OF weak ARE NOT UNIQUE. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Then $r = r'$, and if the premises of $r$ are some 
$\Gamma_1 \vdash t_1:A_1, \ldots, \Gamma_p \vdash t_p:A_p$,
then the list of immediate subterms of $t$ is exactly $(t_1, \ldots, t_p)$.
\end{proposition}

From the typing rules we define the notion of \emph{pre-proof}. 
%Proofs are binary trees labeled on the set $\Rule$.
%, each node is associated to a typing 
%judgment which is a consequence of the typing judgments associated to the 
%children node under some rule $r \in \Rule$ of $\LAMBDA$.

%12:55 29/04/2024

%The next definition is the formal definition of proof.
%
%We mention that we will introduce a restriction we call \emph{left-finite} on proof trees. 
%The restriction left-finite is used to prevent trivial proofs. 
%For instance, we want to forbid a proof cyclically switching the variables $x$ and $y$ in the context of a term,
%by an infinite nesting of $\weak$-rule (Weakening + Exchange  rule):
% \[
%  \infer[\weak]{
%    (x^T:T, y^U:U) \prove t : A
%  }{
%    \infer[\weak]{
%    (y^U:U,  x^T:T) \prove t : A
%  }{\infer*{}{}}
%  }
%  \]
%Another example: we want to forbid an infinite left nesting of applications, as in a proof of 
%$t_{n}:A^n \rightarrow A$ where $t_{n} = t_{n+1}(t_0)$:
% \[
%  \infer[\apnotvar]{
%   \prove t_n : A^n \rightarrow A
%  }{
%    \infer[]{
%   \prove t_{n+1} : A^{n+1} \rightarrow A
%  }{\ldots}
%   &
%   \infer[]{
%   \prove t_{0} : A
%  }{\ldots}
%  }
%  \]
%These proof trees are meaningless and should be ruled out. 

%We ask that all leftmost branches in any sub-proof are finite. 
%The idea is that when the main operation in a programming language is application, 
%then the leftmost branch uniquely  determines the type of the term and therefore it should be finite for the term to make sense.
%%12:54 03/06/2024

%DI QUI 17:35 11/06/2025 
% 10:55 15/0/2025

\begin{definition}[Pre-proofs of $\LAMBDA$]
Assume $\Pi=(T,\phi, \psi)$, that $T$ is a binary tree whose nodes are lists of integers, such
that the root is $\nil$ and the $i$-th child of $l = ( i_1, \ldots, i_n ) \in T$, if any, 
is $l \conc (i) = ( i_1, \ldots, i_n, i)$.
Assume that each node $l \in T$
is labeled by a judgment $\phi(l) \in \Judg$ and a rule $\psi(l) \in \Rule$. 
%(appending $i$ after the last element of $l$).

Let $J$ be a judgment. 
We write $\Pi :: J$, and we say that $\Pi$ is a \emph{pre-proof} of conclusion $J$ if:
\begin{enumerate}
\item 
  The judgment labeling the root $\nil$ of $T$ is the conclusion: $\phi(\nil) = J$.
\item
  If the judgment labeling $l \in T$ is $\phi(l) = J_0$, and if $l$ has $p$ children
  such that $\phi(l \conc (i)) = J_i$ for $i=1, \ldots, p$,
  then $\psi(l)$ is the rule $(J_1,\ldots,J_p,J_0)$.
\end{enumerate}
\end{definition}

%
%We can check that a proof is left-finite if and only if all leftmost paths of all sub-proofs are finite.
%
%In the case of a regular proof, we can decide in polynomial time in the number of sub-proofs whether a
%proof is left-finite. Here is the algorithm. Suppose a possibly infinite proof has $n$ subproofs.
%For each sub-proof we follow the leftmost path, after $n$ steps either we reach some rule without
%premises (either a $\var$-rule or a $0$-rule), or we loop. Then:
%\begin{enumerate}
%\item
%If for all sub-proofs we stop then the proof is left-finite
%\item
%If for some sub-proof we loop, then there is infinite leftmost path and the proof is \emph{not} left-finite.
%\end{enumerate}
%We estimate the computation time to $O(n)$ for each of the $n$ sub-proofs, 
%and the total computation time to $O(n^2)$.
%\\

The notion of pre-proof is too wide, there are non-sensical pre-proofs. 
For example, assume $t_n = t_{n+1}(0)$ is
a term family indexed on $n \in \Nat$. Then, for any type $A$, we can define a pre-proof family
$\Pi_n ::\ (\vdash t_n : \N^n \rightarrow A)$ whose conclusion is obtained by
$\Pi_{n+1} ::\ \vdash t_{n+1} : \N^{n+1} \rightarrow A$ and $\Pi ::\ \vdash 0:\N$. 
There is no obvious interpretation for the term $t_0$, 
and it can have type $A$, which is arbitrary taken. 

For this reason, we say that a term $t$
is well-typed if $\Pi ::\Gamma \vdash t:A$ for some pre-proof $\Pi$ satisfying one extra 
condition, \emph{left-finiteness}, used to remove some non-sensical proofs like above.

\begin{definition}[Well-typed term of $\LAMBDA$]
%\mbox{}
\begin{enumerate}

\item
A path $\pi$ in a pre-proof $\Pi=(T,\phi,\psi)$ from a node $x \in T$ 
is any non-empty sequence of nodes for $T$,
where its first node is $x$, and 
each other node in $\pi$ is a child of the previous one in $\pi$.

\item
A path is \emph{leftmost} if all nodes of $\pi$
but the first are the leftmost child of the previous one.

\item
A pre-proof $\Pi$ is \emph{left-finite} if all leftmost paths in $\Pi$ 
from any node of $\Pi$ are finite.

\item
A term $t$ is \emph{well-typed} if and only if $\Pi :: \Gamma \vdash t:A$ 
for some \emph{left-finite} pre-proof $\Pi$.
% with $\FV(\Gamma) \supseteq \FV(t)$.% this is necessarily true

\item
$\WTyped \subseteq \LAMBDA$ is the set of well-typed terms.

\end{enumerate}

%A proof $\Pi::\Gamma \vdash  t :T$ is canonical if all $\weak$-rules
%\begin{enumerate}
%\item
% either follow some $\lambda$-rule for a term $\lambda x^T.b$, and they introduce $x^T$ in the context,
%\item
%or follow some $\cond$-rule for a term $\cond(f,g)$, and they introduce $x^\N$ in the context,
%\end{enumerate}

\end{definition}

For instance, the family of terms $t_n = t_{n+1}(0)$ has no left-finite proof,
because the leftmost branch must include all sub-terms $t_n, t_{n+1}, t_{n+2}, \ldots$.
Thus, no $t_n$ is well-typed.


\begin{proposition}
Well-typed terms are closed by well-typed substitution:
if $\Pi_1:: x:U, \Gamma \vdash t:A$ and $\Pi_2:: \Gamma \vdash u:U$
are left-finite,
then $\Pi::\Gamma \vdash t[u/x]:A$ for some left-finite pre-proof $\Pi$.
\end{proposition}

%
%Proofs not using the $\weak$-rule are unique, because the first symbol of each 
%subterm forces the rule deriving this subterm. If we add the $\weak$-rule, this is 
%no more true. However, 
%

Using \emph{left-finiteness}, we can prove the \emph{uniqueness} of type for a well-typed term. 

%12:25 13/06/2025

\begin{proposition}[Uniqueness of typing]
\label{proposition-left-finite-unique}
If both $\Pi::\Gamma \vdash t:A$ and $\Pi'::\Gamma' \vdash t:A'$ are two \emph{left-finite} pre-proofs,
then $A = A'$.
\end{proposition}

%
%%08:56 19/06/2024
%\begin{proof}
%By induction on the sum of the length of the leftmost branch in $\Pi$ and $\Pi'$. These lengths are finite
%because $\Pi$ and $\Pi'$ are assumed to be left-finite. Let $r$ be the last rule of $\Pi$ and $r'$ be the
%last rule of $\Pi'$.
%\begin{enumerate}
%\item
%Assume $r = \weak$. Then $\Pi$ is obtained from a proof $\Pi_1:\Gamma_1 \vdash t:A$. 
%By induction hypothesis on $\Pi_1$ and $\Pi'$ we conclude that $A = A'$.
%
%\item
%Assume $r \not = \weak$ and $r' = \weak$. 
%Then $\Pi'$ is obtained from a proof $\Pi'_1::\Gamma_1 \vdash t:A$. 
%By induction hypothesis on $\Pi$ and $\Pi'_1$ we conclude that $A = A'$.
%
%\item
%Assume  $r \not = \weak$ and $r' \not = \weak$. Then both $r$ and $r'$ are the typing rule for
%the outermost constructor of $t$ and for some
%$h=0,1,2$ the proof $\Pi$ has premises $\Pi_1, \ldots, \Pi_h$
%and the proof $\Pi'$ has premises $\Pi'_1, \ldots, \Pi'_h$ (for the same $h$). 
%We distinguish one case for each constructor.
%
%\begin{enumerate}
%\item
%Assume $t = x^T$. Then $r=r'=\var$-rule and $A = A' = T$.
%
%\item
%Assume $t =0^\N$. Then $r=r'=0$-rule and $A = A' = \N$.
%
%\item
%Assume $t =\Succ(u)$. Then $r=r'=\Succ$-rule  and $\Pi_1::\Gamma \vdash u: \N$
%and $\Pi_2::\Gamma' \vdash u:\N$ and $A = A' = \N$.
%
%\item
%Assume $t = f(u)$. Then $r=r'=\ap$-rule and $\Pi_1::\Gamma \vdash f:U \rightarrow A$
%and $\Pi_2::\Gamma' \vdash f:U' \rightarrow A'$. By induction hypothesis on $\Pi_1$ and
%$\Pi'_1$ we deduce that $(U \rightarrow A) = (U' \rightarrow A')$, in particular that $A = A'$.
%
%\item
%Assume $t = \lambda x^T.b$. Then $r=r'=\lambda$-rule and 
%$\Pi_1::\Gamma \vdash b:B$
%and $\Pi_2::\Gamma' \vdash b:B'$. By induction hypothesis on $\Pi_1$ and
%$\Pi'_1$ we deduce that $B=B'$, in particular that $A = T \rightarrow B = T \rightarrow B' = A'$.
%
%\item
%Assume $t = \cond(f,g)$. Then $r=r'=\cond$-rule and $\Pi_1::\Gamma \vdash f:A$
%and $\Pi_2::\Gamma' \vdash f:A'$. By induction hypothesis on $\Pi_1$ and
%$\Pi'_1$ we deduce that $A = A'$.
%
%\end{enumerate}
%\end{enumerate}
%\end{proof}

%
%We provide some examples of well-typed and not well-typed terms.
%%23:30 23/04/2024
%Some term in $\LAMBDA$ has no type, like the application $0(0)$ of the non-function $0$. 
%
%\begin{Eg}
%We provide a term in $\LAMBDA$ having more than one type.
%Let $t=u(0)$ and $u=\cond(t,u)$. $t$ has an infinite lefmost branch $t,u,t,u, \ldots$, therefore
%$t$ is not left-finite and it has no \emph{left-finite typing proof}.
%Unicity fails and we can prove $\vdash t:A$ for all types $A \in \Type$. 
%The subterms of $t$ are $\{t, u, 0\}$ and a proof $\Pi:: \emptyset \vdash t:A$ is
%\[
%\infer[\apnotvar]{
%  \prove t : A
%}{
%  \infer[\cond]{
%    \prove u:\N \rightarrow A
%  }{
%    \infer*{
%      \prove t : A
%    }{}
%    &
%    \quad
%    &
%    \infer*{
%      \prove u : \N \rightarrow A
%    }{} 
%  }
%  &
%  \quad
%  &
%  \infer[0]{
%    \prove 0:\N
%  }{}
%}
%\]
%Formally, the typing proof $\Pi=(T,\phi):\vdash t:A$ 
%is defined by $\universe{\Pi}=\universe{t}$ and:
%\begin{enumerate}
%\item
%$\Label(\Pi,l)=(\vdash A)$ \ \ \ \ \ \ \ for all $l \in \universe{t}$ such that  $t \restr l = t$,
%\item
%$\Label(\Pi,l) = (\vdash \N \rightarrow A)$  for all $l \in \universe{t}$ such that $t \restr l = u$,
%\item
% $\Label(\Pi,l)=(\vdash\N)$ \ \ \ \ \ \ \  for all $l \in \universe{t}$ such that $t \restr l = 0$. 
%\end{enumerate}
%%09:06 24/04/2024
%\end{Eg}
%
%
%A term with at least two types has the leftmost branch infinite, as it is the case for $t$ above.
%We proved that if \emph{all} subterms of a term have the leftmost branch finite, then the term 
%has at most one type.
%
%
%\emph{Claim (existence of a polynomial-time typing algorithm)}.
%We claim without proof that if a term $t$ is regular then we can decide if an left-finite proof 
%$\Pi::\Gamma \vdash A$ exists. If an left-finite proof $\Pi$ exists 
%then at least one of left-finite proofs is regular and we can compute it. 
%We first check whether the term is left-finite in time $O(n^2)$. If it is not we reject the term.
%Otherwise we start the standard recursive typing algorithm, until a type has been inferred consistently
%for each of the finitely many subterms, or some type inconsistency has been found.
%In the first case we accept the term and we return the time, in the second case we reject the term
%and we return no type.
%The computation requires quadratic time in the size of the graph representing the term.


%10:26 20/04/2024
%13:49 29/04/2024
%12:20 27/03/2025

We give a typical example $\Sum$ of our system. $\Sum(x)(y)$ will be interpreted
as the sum of $x$ and $y$. $\Sum$ is regular and well-typed.
Moreover, as we will see later, $\Sum$ satisfies the global trace condition,
and hence it is in $\CTlambda$ (see Example~\ref{example-sum}). 

% 11:31 15/07/2025

\begin{example}\label{example-sum-first}
Let $\Sum$ be an infinite term that satisfies 
$\Sum = \lambda x.\cond(x,\lambda y.\Succ(\Sum(x)(y)))$.
$\Sum$ is regular because the set $\SubTerm(\Sum)$ is finite and equals to: 
\begin{center}
  $\{\Sum,\,\cond(x,\lambda y.\Succ(\Sum(x)(y))),\,x\,,\lambda y.\Succ(\Sum(x)(y)),\,\Succ(\Sum(x)(y)),\,\Sum(x)(y),\,\Sum(x),\,y\,\}$
\end{center}
$\Sum$ is well-typed by the derivation of Figure~\ref{fig:sum-proof}
with a unique infinite path (call it $\pi$).
In $\pi$, we put {\color{blue} \bf blue}/{\color{red} \bf red}
arrows to specify a sequence of $\N$s for a reason we will explain later\footnote{
The sequence of $\N$s passed through by arrows is an infinitely progressing trace (with progressing points specified by the red arrow), 
which will be defined in Section~\ref{section-circular-system-CTlambda}, g
following the path $\pi$.}.
This infinite tree is represented by a finite cyclic graph 
adding a back edge (drawn in {\color{black} \bf black}) 
from the upper sequent with $(\dagger)$
to the bottom sequent with $(\dagger)$.
Note that the use of $\weak$-rule works for this cyclic graph representation,
namely, without $\weak$, this particular pre-proof would be incorrect.
%the context of the top $\golddagger$ would be $(x:\N, y:\N)$ 
%while the context of the bottom $\golddagger$ is empty.

\begin{figure}[t]
  \begin{prooftree}
    \AxiomC{}
    \UnaryInfC{$x : \N \vdash x : \N$}
    \AxiomC{$\vdots$}
    \noLine
    \UnaryInfC{$\vdash \Sum: \N\rightarrow\vnode8{\N}\rightarrow\N$
    \quad ($\vnode9{\dagger}$)}
    \RightLabel{$\weak$}
    \UnaryInfC{$x:\N, y : \vnode7{\N} \vdash \Sum: \N\rightarrow\N\rightarrow\N$}
    \RightLabel{$\apvar$}
    \UnaryInfC{$x:\N, y : \vnode6{\N} \vdash \Sum(x): \N\rightarrow\N$}
    \RightLabel{$\apvar$}
    \UnaryInfC{$x:\N, y : \vnode5{\N} \vdash \Sum(x)(y): \N$}
    \RightLabel{$\Succ$}
    \UnaryInfC{$x:\N, y : \vnode4{\N} \vdash \Succ(\Sum(x)(y)): \N$}
    \RightLabel{$\lambda$}
    \UnaryInfC{$x:\N \vdash \lambda y.\Succ(\Sum(x)(y)): \vnode3{\N} \rightarrow \N$}
    \RightLabel{$\cond$}    
    \BinaryInfC{$x : \N \vdash \cond(x,\lambda y.\Succ(\Sum(x)(y))): \vnode2{\N} \rightarrow \N$}
    \RightLabel{$\lambda$}
    \UnaryInfC{$\vdash \Sum:\N \rightarrow \vnode1{\N} \rightarrow \N$
    \quad ($\vnode0{\dagger}$)}
  \end{prooftree}
  $
  \dirflowedges{node1/node2}
  \dirflowrededges{node2/node3}
  \dirflowedges{node3/node4}
  \dirflowedges{node4/node5}
  \dirflowedges{node5/node6}
  \dirflowedges{node6/node7}
  \dirflowedges{node7/node8}
  \bentdirflowedges{node8/node1/-90}
  \bentflowblackedges{node9/node0/120}
  $    
  \caption{Typing of $\Sum$}\label{fig:sum-proof}
\end{figure}

\end{example}

Our goal is to provide a set of well-formed terms for $\LAMBDA$ and interpret 
them as total functionals. %, a semantics for circular $\lambda$-terms.
The well-typedness condition is not enough for our purpose,
since terms like $t = \cond(0,\lambda x.t(\Succ(x)))$ which
denote partial functionals  are still included. 
The global trace condition (to be introduced later) will be a reasonable condition for our goal. 
%to denote a subset of the total functionals. 

\subsection{Reduction rules}
This subsection provides reduction rules for $\LAMBDA$.
%18:14 27/03/2024

\begin{definition}[Reduction Rules for $\LAMBDA$]
  Let $f$, $t$ and $u$ be terms in $\LAMBDA$.
  We define the $\beta$-reduction relation $\reduces_\beta$
  and the $\cond$-reduction relation $\reduces_\cond$ as follows.
\begin{description}
\item[$\beta$-reduction:]
  $(\lambda x^A.t)(u) \reduces_\beta t[u/x]$, 
\item[$\cond$-reduction:] 
  $\cond(u,f)(0) \reduces_\cond u$ and 
  $\cond(u,f)(\Succ (t)) \reduces_\cond f(t)$.
\end{description}
\end{definition}

A \emph{$\beta$-redex} or \emph{$\cond$-redex} is a term in the shape of the term at the left-hand side of $\reduces_\beta$ or $\reduces_\cond$, respectively. 
The \emph{one-step reduction relation} $\reduces$
is the contraction of one $\beta$ or of one $\cond$ redex anywhere
in the term, namely,
it is the union of the context closures of $\reduces_\beta$ and $\reduces_\cond$.
The relation $\reduces^*$ is the reflexive and 
transitive closure of $\reduces$ (zero or more reductions).
The relation $\reduces^{+}$ is the 
transitive closure of $\reduces$ (one or more reductions).

%$a \sim b$ is the existence of a common reduct: 
%$\exists c \in \LAMBDA. (a \reduces^* c) \wedge (b \reduces^* c)$.

\begin{definition}[$\cond$-depth]
\begin{enumerate}
\item
The \emph{$\cond$-depth} of a subterm $u$ of a term $t$ is 
the number of edges between a $\cond$ node and its right child on the path
from $t$ to $u$. 
\item
The \emph{$n$-safe level} of $t$ is the set of nodes of $t$ with $\cond$-depth $\le n$.
\end{enumerate}
\end{definition}

We say that $t \nsafeReduces{n} u$, or that $t$ $n$-safely reduces to $u$,  
if we reduce $t$ to $u$ by contracting a single redex in the $n$-safe level of $t$ 
(i.e. of $\cond$-depth $\le n$).
%We call \emph{unsafe} a reduction inside any $\cond(f,g)$.
A term is $n$-safe-normal if all its redexes (if any) have $\cond$-depth $>n$.
We abbreviate \quotationMarks{$t$ is $0$-safe-normal} 
with just \quotationMarks{$t$ is safe-normal} and write $\safeReduces$ instead of $\nsafeReduces{0}$.


%09:19 24/04/2024
%14:00 29/04/2024

%% \begin{example}
%% Let $u \sim \cond(0, (\lambda z.u)(z) )$. Then $u$ is safe-normal, 
%% because all redexes in $u$ are of the form  $(\lambda z.u)(z)$ and are in the right-hand side
%% of a $\cond$. However $u$ has infinitely many nodes which are $\beta$-redexes.
%% Up to tree isomorphism, the tree form of $u$ includes the following branch:
%% \begin{center}
%%   $u$, 
%%   \quad
%%   $(\lambda z.u)(z)$, 
%%   \quad
%%   $\lambda z.u$, 
%%  \quad
%%   $u$, 
%%  \quad $\ldots$
%% \end{center}
%% This infinite branch is cyclic,
%% and includes infinitely many $\beta$-redexes.
%% %all isomorphic to the same term $(\lambda z.u)(z)$. 
%% It takes infinitely many $\beta$-reductions to normalize $t$,
%% therefore $u$ has no normal form.
%% \end{example}

%% In order to produce the output of a computation we have
%% to reduce closed terms of type $\N$ to a numeral. 
%% We will define a subset $\CTlambda$ of
%% $\LAMBDA$ and prove that if we repeat $0$-safe-reductions 
%% (those in the right-hand side of \emph{no} $\cond$) on any
%% closed term of type $\N$ of $\CTlambda$ eventually we obtain a numeral. 
%% We will in fact prove that the $0$-safe-reduction relation is strongly normalizable on \emph{any} term
%% of $\CTlambda$. 

%14:11 25/03/2025

\begin{example}
For an example of safe-reductions from a term to a normal form, 
assume $n \in \Num$ is any numeral and $v = \cond(1, v)$.
$v$ is normal (it is no $\cond$-redex).
There is a unique reduction sequence
$v(n) \safeReduces v(n-1) \safeReduces \cdots \safeReduces v(0) \safeReduces 1$. 
Thus, $v(n)$ strongly normalizes by $\safeReduces$ to $1$ in $(n+1)$ steps.
%$v(n)$ has a unique reduction path,
%having length $(n+1)$ and terminating in $1$.
The output is independent from $n$.
\end{example}

\begin{example}
This is an example of safe-reductions from a term $\Sum(m)(n)$ to
its normal form $m+n$. 
$\Sum$ is normal.
We have $\Sum(m)(n) \safeReduces \cond(m,\lambda y.\Succ(\Sum(m)(y)))(n) \safeReduces \Succ(\Sum(m)(n-1))$.
Hence there is unique $0$-safe-reduction sequence 
$\Sum(m)(n) \safeReducesAst \Succ(\Sum(m)(n-1)) \safeReducesAst \cdots \safeReducesAst \Succ^n(\Sum(m)(0)) \safeReducesAst \Succ^n(m) = m+n$.
Thus, the term $\Sum(m)(n)$ strongly normalizes by $\safeReduces$.
Note that we only used safe-reductions.
\end{example}

We will exhibit meaningful terms of $\CTlambda$ without a normal form. 
However, for those terms we will define \quotationMarks{a limit normal form},
in a sense we will make precise.

