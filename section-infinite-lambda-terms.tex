\section{The set of infinite lambda-terms}\label{section-infinite-lambda}

In this section we define the set $\LAMBDA$ of infinite circular terms, the subset $\WTyped$
of well-typed terms of $\LAMBDA$ and a reduction relation for them. In the next sections,
we will prove that the regular well-typed terms of $\LAMBDA$ which satisfy the
Global Trace Condition also satisfy a termination result.

%They will be used to
%give a semantics for finite circular notations for $\lambda$-terms.

%Infinite terms are labeled at most countable binary trees.
%
%, therefore we
%provide a formal definition of at most countable binary trees first.
%, and before them the lists on $\{1,2\}$ and
%some related notions.
%
%\subsection{Lists and Binary Trees}
%
%\begin{definition}(Lists on $\{1,2\}$)
%\begin{enumerate}
%\item
%We denote with $\List(\{1,2\})$ the set of all lists on $\{1,2\}$, just lists for short.
%\item
%If $i_1, \ldots, i_n \in \{1,2\}$, we write $(i_1, \ldots, i_n)$
%for the list with elements $i_1, \ldots, i_n$. 
%\item
%We write $\nil$ for the empty list, or $()$. 
%\item
%If $l=(i_1, \ldots, i_n), m=(j_1, \ldots, j_m) $ are lists
%we define
%$
%l \conc m = (i_1, \ldots, i_n,\ j_1, \ldots, j_m)
%$
%%If $I \subseteq \List(\{1,2\})$
%%we write $l \conc I = \{l \conc m \mid m \in I\}$. 
%\item
%The prefix order $\le$ on lists
%is defined by $l \le m$ if and only if $m = l \conc m'$ for some $m' \in  \List(\{1,2\})$.
%\end{enumerate}
%\end{definition}
%
%Binary trees can be represente represented by sets of lists on $\{1,2\}$.
%
%\begin{definition}(Binary trees)
%\begin{enumerate}
%\item 
%A binary tree, just a tree for short, is any set $T\subseteq \List(\{1,2\})$ 
%of lists including the empty list and closed by prefix: $\nil \in T$ and for all $l, m \in \List(\{1,2\})$
%if $m \in T$ and $l \le m$ then $l \in T$. 
%
%\item
%$\nil$ is called the root of $T$, any $l \in T$ is called a node of
%$T$ and if $l \in T$, then any $l \conc (i) \in T$ is called a child of $l$ in $T$
%of index $i$.
%
%\item
%A node $l$ of $T$ is a leaf of $T$ if $l$ is an maximal element of $T$ w.r.t. the prefix order (i.e.,
%if $l$ has no children). 
%
%\item
%If $T$ is a tree and $l \in T$ we define $T \restr l = \{m \in \List(\{1,2\}) \mid l \conc m \in T\}$.
%$T \restr l$ is a tree and we say that $T \restr l$ is a subtree of $T$ in the node $l$,
%and for each $m \in T \restr l$ we say that $l \conc m$ is the corresponding node in $T$.
%\item
%
%If $l=(i)$ we say that $T \restr l$ is an immediate sub-tree of $T$.
%\item
%A binary tree labeled on a set $L$ is any pair $\setT = (T, \phi)$ with 
%$\phi:T \rightarrow L$. We call $\universe{\setT}=T$ the set of nodes of $\setT$.
%For all $l \in T$ we call $\Label(\setT,l) = \phi(l)$ the label of $l$ in $\setT$.
%\item
%We define $\setT \restr l = (T \restr l, \phi_l)$ and $\phi_l(m) = l \conc m$. 
%We call any $\setT \restr l$ a labeled subtree of $\setT$
%in the node $l$, an immediate sub-tree if $l=(i)$. 
%\end{enumerate}
%\end{definition}

%Remark that the labeling of a node $m \in \universe{( \setT \restr l )}$ 
%is the same label of the corresponding node $l \conc m$ of $\universe{\setT}$.
% 
%Let $n = 0, 1, 2$. We define an operation $l(\setT_1, \ldots, \setT_n)$
%combining labeled trees which we will use to produce tree notation. 
%Assume $\setT_1, \ldots,\setT_n$ are trees labeled on $L$ and $l \in L$.
%Then we define $$\setT = l(\setT_1, \ldots, \setT_n)$$ 
%as the unique tree $\setT$ labeled on $L$ with the root labeled $l$ and with:
%$\setT \restr (i) = \setT_i$ for all $1 \le i \le n$.

\subsection{Types, terms and contexts}
We define the set $\LAMBDA$ of infinite binary tree notations: 
first the types for $\LAMBDA$, 
then the terms and the contexts for $\LAMBDA$.

\begin{definition}(Types)
We fix a countable set $\{\alpha,\beta,\ldots\}$ of type variables. 
\begin{enumerate}
\item  
  The \emph{simple types} (or \emph{type} for short), denoted by $T,A,B,\ldots$,
  of $\LAMBDA$ are inductively defined by: 
  $\N$ of natural numbers, type variables, and $A \rightarrow B$, provided $A$ and $B$ are types.
  We write $\Type$ for the set of simples types.
\item
  We abbreviate $A_1 \rightarrow (A_2 \rightarrow \cdots (A_n \rightarrow B))$
  with $A_1,A_2,\ldots,A_n \rightarrow B$ and also, more shortly,  
  with $\vec{A} \rightarrow B$ when $\vec{A} = A_1, \ldots, A_n$.
  In particular, we write $A^n \rightarrow B$ when $A_1,\ldots,A_n$ are the same type $A$. 
\end{enumerate}
\end{definition}

Terms of our system are possibly infinite binary trees, with each node labeled by 
some connective on $\lambda$-terms with its arity (number of children) $0$, $1$, or $2$.

\begin{definition}(Variables and terms)
We fix a countable set $\{x,y,\ldots\}$ of variable names. 
\begin{enumerate}
\item
A \emph{variable} $x^T$ is a type name $x$ with a type superscript $T$. 
\item  
A \emph{term} is a labeled binary tree, denoted by $t,u,v,\ldots$, with labels 
$x^T$, $\lambda x^T$, $\ap$, $0$, $\Succ$, and $\cond$, such that:
\begin{enumerate}
\item 
a node labeled $x^T$ or $0$ has \emph{no} children;

\item
a node labeled $\lambda x^T$ or $\Succ$ has a \emph{unique} child;

\item
a node labeled $\ap$ or $\cond$ has \emph{two} children.
\end{enumerate}  
\item
The set of all terms is denoted by $\LAMBDA$.
\end{enumerate}

We say that $u$ is a subterm of $t$ if $u$ is a sub-tree of $t$,
with labeling the restriction of the labeling of $t$ to the nodes of $u$.
An immediate subterm is an immediate sub-tree.
\end{definition}

We define a tree isomorphism between two possibly infinite trees by
a bijection on nodes that preserves root, edges, and the children-order of corresponding parent nodes. 
We write $t \sim u$ and read \quotationMarks{$t$ and $u$ are isomorphic terms}
if and only if there is some label-preserving tree isomorphism between $t$ and $u$.
We may identify two isomorphic terms when we are interested in the shape of these terms,
but, in general, we do not identify them because we need to distinguish different occurrences
of redexes (defined later), which may have the same shape in an infinite term. 

We often write a term by its (possibly infinite) one-line denotation,
namely, a term with the root labeled $x^T$, $0$,
$\Succ$ with a child $t$,
$\lambda x^T$ with a child $t$,
$\ap$ with (left and right) children $t$ and $u$,
$\cond$ with children $t$ and $u$ is denoted by
$x^T$, $0$, $\Succ(t)$, $\lambda x^T.t$, $\ap(t,u)$, $\cond(t,u)$, respectively. 
This denotation is unique up to term isomorphism.
Conversely, each $v \in \LAMBDA$ is in one of the forms:
$x^T, 0, \lambda x^T.t$, $\ap(t,u)$, $\Succ(t)$, $\cond(t,u)$ for some $t, u \in \LAMBDA$.
As usual, we abbreviate $\ap(t,u)$ with $t(u)$.

Now we define the regular terms of $\LAMBDA$.

%11:55 22/04/2024

\begin{definition}(Regular terms of $\LAMBDA$)
%\mbox{}
\begin{enumerate}

\item
We write $\SubTerm(t) = \{\,u \mid \mbox{$u$ subterm of $t$}\,\}/\!\sim$ 
for the set of subterms of $t$, with isomorphic terms identified. 

\item
$\Reg$ is the set of terms $t \in \LAMBDA$ such that $\SubTerm(t)$ is finite
(up to term isomorphism there are only finitely many subterms of $t$).
We call the terms of $\Reg$ the \emph{regular terms}.

%\item
%We write $\Tree(t)$ for the tree of all chains
%$(t_1, \ldots, t_n)$ with $t_1=t$ and weakly increasing by $\sqsubset_1$: 
% for all $(i+1) \le n$ we have $t_{i+1}=t_i$ or $t_{i+1} \sqsubset_1 t_i$.

\item
When $t = \Succ ^n(0)$, namely $\Succ(\cdots \Succ(0))$ ($n$-times of $\Succ$), for some natural number $n \in \Nat$,
we say that $t$ is a numeral. We write $\Num$ for the set of numerals.

\end{enumerate}
 
\end{definition}

%We use two different names for the operation $\ap(t,u)$: 
%we call it $\ap$ when $u$ is not a variable and $\apvar$ when $u$ is a variable. 

The set $\Num$ is the representation of the set $\Nat$ of natural numbers inside $\LAMBDA$. 

\begin{Eg}
\label{example-regular-infinite}
An example of a regular term and an infinite tree: the term defined by the isomorphism
$t \sim \cond(0,\lambda x^N.t(x))$. 
Then $\SubTerm(t) = \{t,0,\lambda x.t(x), t(x), x\}$, up to term isomorphism.
Thus, $t$ is a regular term.
However, $t$ is an infinite tree (it includes a proper subtree isomorphic to itself). 
\end{Eg}


%Regular terms have \emph{finitely many} distinct variables, 
%even if each variable can occur infinitely many times in the tree,
%like $x$ in $t$ above. Through renaming of bound variable a regular term 
%can be $\alpha$-equivalent to a non-regular infinite term 
%with infinitely many distinct bound variables. In the example above we can
%rename each occurrence of $\lambda x.t(x)$ in the infinite tree 
%to $\lambda x'.t(x')$, $\lambda x''.t(x'')$, \ldots, the infinite term $t'$ we obtain
%in this way has infinitely many subterms $x', x'', \ldots$, therefore it is not
%regular, yet is it $\alpha$-equivalent to the regular term $t$.

The binder relation is defined as for finite $\lambda$-calculus 
(\cite{Barendregt1984-BARTLC}, \S 2.1.6 p. 24). 

\begin{definition}(Binding relation)
\label{definition-binder-relation}
Let $t$ be a term.
\begin{enumerate}
\item
An occurrence of a variable $x^T$ in $t$ is any node of $t$ labeled $x^T$.
\item
An occurrence of a variable $x^T$ in $t$ is said to be \emph{free} if there is no node labeled $\lambda x^T$
in the path from the root of $t$ to the occurrence. 
$\FV(t)$ is the (finite or infinite) set of variables having at least one free occurence in $t$.
\item
An occurrence of $x^T$ in $t$ is said to be \emph{bound} if it is not free. If an occurrence is bound, then
the node labeled $\lambda x^T$ closest to the occurrence is called the \emph{binder} of
the occurrence.
The binding relation is a binary relation from a node occurrence of a bound variable to the node of its binder. 
\end{enumerate}
\end{definition}

We also introduce an $\alpha$-conversion relation, in order to avoid variable capture
during substitution. With respect to the $\alpha$-conversion
relation for finite $\lambda$-terms (\cite{Barendregt1984-BARTLC}, \S 2.1.11 p.26) 
we add the requirement that equal bound variables are renamed by equal bound variables. 
In this way, we only consider $\alpha$-conversions 
preserving the regularity of a term.


\begin{definition}(Equality-preserving $\alpha$-conversion)
\label{definition-alpha-conversion}
Let $t$ and $u$ be terms.
\begin{enumerate}
\item
We say that $\phi:t \rightarrow u$ is an \emph{$\alpha$-conversion map} if and only if 
$\phi$ is a tree isomorphism between $t$ and $u$ such that:
\begin{enumerate}
\item
$\phi$ preserves all labels except for $\lambda x^T$ and $x^T$;
\item 
$\phi$ preserves all labels $x^T$
on a free variable occurrence, and the fact that it is free;
\item
$\phi$ sends each label $\lambda x^T$ to some label $\lambda y^T$, each label $x^T$
on a bound variable to some label $y^T$ on a bound variable, and preserves the
binding relation. 
\end{enumerate}

\item
We say that an $\alpha$-conversion map $\phi$ is equality-preserving if $\phi$ maps equal
labels into equal labels.

\item
We write $t \sim_\alpha u$ if there is some \emph{equality-preserving} 
$\alpha$-conversion $\phi:t \rightarrow u$.
\end{enumerate}
\end{definition}

In order to define typing of our possibly infinite terms, we first 
define contexts and typing judgments.

%13:32 22/04/2024
%11:17 29/04/2024

\begin{definition}(Contexts and typing jugdments for $\LAMBDA$)
\label{definition-context-lambda}
\begin{enumerate}

\item
\label{definition-context-lambda-01}
A \emph{context}, denoted by $\Gamma, \Delta$, is a finite list
$(x_1^{A_1}:A_1,\ldots,x_n^{A_n}:A_n)$ of type assignments to distinct
variables.
The set $\FV(\Gamma)$ is the set of variables in a context $\Gamma$.
We write $\Ctxt$ for the set of contexts.
%% A  context of $\LAMBDA$ is any finite list 
%% $\Gamma = ({x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_n)$ 
%% of \emph{distinct variables}, for some $A_1, \ldots, A_n \in \Type$. 
%% We denote the empty context with $\nil$. 
%We write $\Ctxt$ for the set of all contexts.

%% \item
%% \label{definition-context-lambda-05}
%We say that $\Gamma$ is a context for $t \in \LAMBDA$ and we write $\Gamma 
%\vdash t$ if $\FV(t) \subseteq \FV(\Gamma)$.

%\item
%\label{definition-context-lambda-03}
%A sequent is a pair $(\Gamma, A)$ of a context $\Gamma$ and a type $A$.
%%, which we write as $\Gamma \vdash A$. 
%We write $\Judg = \Ctxt \times \Type$ for the set of all sequents.

\item
\label{definition-context-lambda-07}
The context $\Gamma\setminus\{x^T:T\}$ is the one obtained
by removing $x^T:T$ from $\Gamma$ if the type assignment presents. 
Otherwise $\Gamma\setminus\{x^T:T\}$ is $\Gamma$.

\item
\label{definition-context-lambda-08}
  Let $\Gamma$ and $\Gamma'$ be $({x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_n)$ and $({x'_1}^{A'_1}:A'_1, \ldots, x'_{n'}^{A'_{n'}}:A'_{n'})$, respectively. 
We write $\phi:\Gamma \rightarrow \Gamma'$ if and only if
$\phi:\{1,\ldots,n\} \rightarrow \{1,\ldots,n'\}$ is an injection
and we have $x_{i}=x'_{\phi(i)}$ and $A_{i}=A'_{\phi(i)}$ for all $i \in \hbox{dom}(\phi)$. 
Note that we have $\FV(\Gamma) \subseteq \FV(\Gamma')$ if and only if 
$\phi:\Gamma \rightarrow \Gamma'$ for some unique map $\phi$. 

\item 
\label{definition-context-lambda-04}
A \emph{typing judgment} is $(\Gamma,t,A) \in \Ctxt \times \LAMBDA \times \Type$,
which is written in the form $\Gamma \vdash t:A$.
When $\Gamma$ is the empty context $\nil$, we abbreviate $\nil\vdash t:A$ with $\vdash t:A$. 
We write $\Judg$ for the set of all typing judgments.

%\item
%\label{definition-context-lambda-06}
%If $\Gamma = ({x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_n)$ ,
%$\Gamma' = (x'_1:A'_1, \ldots, x'_n:A'_{n'})$ are contexts of $\LAMBDA$, then we write $\Gamma \ \subseteqsim \ \Gamma'$ \ if for all $(x^A:A)$:  \ 
%$(x^A:A) \in \Gamma  \ \Rightarrow  \  (x^A:A)\in\Gamma'$.
%
%\begin{enumerate}
%\item
%$\Gamma \ \subseteqsim \ \Gamma'$ \ if for all $(x^A:A)$:  \ 
%$(x^A:A) \in \Gamma  \ \Rightarrow  \  (x^A:A)\in\Gamma'$
%
%\item
%$\Gamma \sim \Gamma'$  \  if for all $(x^A:A)$:  \ 
%$(x^A:A) \in \Gamma  \ \Leftrightarrow  \  (x^A:A)\in\Gamma'$
%\end{enumerate}

\end{enumerate}
%As usual, we informally write a sequent $(\Gamma, A)$ for $t$ in the form $\Gamma \vdash t:A$.
\end{definition}

In fact a type assignment $x^T:T$ is a \emph{redundant information} for our
variables (not for our terms), 
since each variable already has its type superscript.
However we write $x^T:T$ for uniformity with the notation $x:T$ 
in use in Type Theory.



%We have  $\Gamma \sim \Gamma'$ if and only if  $\Gamma \subseteqsim \Gamma'$
%and  $\Gamma \supseteqsim \Gamma'$ if and only if $\Gamma$, $\Gamma'$ are permutation
%each other if and only if the map $\phi$ above is a bijection. We do not identify two contexts
%which are one a permutation of the other, therefore we will need a rule to move from one to the other.


%12:38 17/04/2024
%15:37 17/04/2024

%From the context for a term we can define a context for each subterm of the term.


%21:26 19/04/2024

%\begin{definition}[Inherited Contexts of $\LAMBDA$]
%
%Given any context $\Gamma$, any $t \in \Lambda$ and any subterm chain 
%$\pi = (t_1, \ldots, t_n) \in \Tree(t)$, we define a unique inherited context for $t_n$ in $\pi$.
%The inherited context is obtained by repeatedly adding $x^T:T$ to the context whenever we
%cross a term $t_i = \lambda x^T.u_i$, while simultaneously removing $x^T:T$ from the previous
%context, if it was there.
%%08:00 20/04/024
%
%\begin{enumerate}
%
%\item
%$t$ has inherited context $\Gamma$.
%
%\item
%Any binder on $x$ subtracts the variable $x$ from the context of its \emph{last} argument:
%if $t = \lambda x^T.u, \cond(f,g)$ has inherited context $\Delta$, 
%then $u$ and $g$ have context $\Delta \setminus \{x^T:T\}, x^T$, 
%while $f$ has  inherited context $\Delta$.
%
%\item
%In any other case the context of a term and of the immediate subterm are the same:
%ff $t=\Succ(u), f(a)$ have inherited context $\Delta$,
% then $u,f,a$ have  inherited context $\Delta$.
%\end{enumerate}
%We abbreviate \emph{`` inherited context from $\Gamma$''} with \emph{context}
%when $\Gamma$ is fixed.
%\end{definition}



%The scope of the binder $\lambda x^T.t$ is $t$.
%The scope of the binder $\cond(f,g)$ is $g$ ($f$ is \emph{not} in the scope of $\cond(f,g)$).

Assume that terms $t$ and $u$ have finitely many free variables. 
We define the term $t[u/x]$ obtained by substituting $u$ for all free occurrences of $x$ in $t$, 
by first replacing $t$ with some $t' \sim_\alpha t$
in order to avoid that free occurrences in $u$ become bound after substitution. 
This is always possible: if there are only finitely many free variabiles in $u$, we can
rename all bound variables in $t$ in order to make them different from the free variables
in $u$. The resulting term $t[u/x]$ still has finitely many free variables.

The use of $\alpha$-convertibility for substitution is not relevant in this paper. Indeed,
substitution of a closed term $u$ requires no renaming, and  in order to use 
infinite $\lambda$-terms as a programming language we only need computations 
involving substitution of closed terms. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%IN THE CONGRESS VERSION I WOULD NOT INCLUDE THE
% EQUATIONS FOR SUBSTITUTION
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%In order to define the capture avoiding substitution
%under the assumption of not having implicit $\alpha$-equivalence, 
%we implicitly fix a well-order on variables
%and define the simultaneous substitution,
%written $t[u_1/x_1,\ldots,u_n/x_n]$ or $t[\vec{u}/{\vec{x}}]$,
%namely it satisfies the following:
%\begin{itemize}
%\item
%  $x_i[u_1/x_1,\ldots,u_n/x_n] = u_i$ and $y[\vec{u}/\vec{x}] = y$, where $y\not\in\vec{x}$. 
%\item
%  $(f(a))[\vec{u}/\vec{x}] = f[\vec{u}/\vec{x}](a[\vec{u}/\vec{x}])$.
%\item
%  $(\lambda z^T.b)[\vec{u}/\vec{x}] =
%  \left\{
%  \begin{array}{ll}
%    \lambda z^T.(b[\Restrict{(\vec{u}/\vec{x})}{\overline{z}}]),
%    &
%    \text{if $z \not\in \FV(\vec{u})$},
%    \\
%    \lambda z'^T.(b[\Restrict{(\vec{u}/\vec{x})}{\overline{z}},z'/z]),
%    &
%    \text{otherwise},
%  \end{array}
%  \right.$
%  \\
%  where
%  $\Restrict{(\vec{u}/\vec{x})}{\overline{z}}$ is the one obtained by removing $u/z$ (for some $u$) from $\vec{u}/\vec{x}$,
%  and 
%  $z'$ is the least variable (with respect to the well-order)
%  such that $z' \not\in \FV(b,\vec{u})$.
%\item
%  $0[\vec{u}/\vec{x}] = 0$.
%\item
%  $\Succ(t)[\vec{u}/\vec{x}] = \Succ(t[\vec{u}/\vec{x}])$.
%\item
%  $\cond(f,g)[\vec{u}/\vec{x}] = \cond(f[\vec{u}/\vec{x}],g[\vec{u}/\vec{x}])$.
%\end{itemize}
%
%Formally we define the substitution as follows.
%\begin{definition}[Substitution for terms of $\LAMBDA$]
%  A set $\theta=\{u_1/x_1,\ldots,u_n/x_n\}$ is called a {\em substitution}
%  if $x_1,\ldots,x_n$ are pairwise distinct variables.
%  It is called {\em renaming} if $u_1,\ldots,u_n$ are pairwise distinct variables. 
%  We define $\theta(y)$ by $u_i$ if $y=x_i$, and by $y$ otherwise.
%  We write $\theta,\theta'$ if $\theta\cup\theta'$ is a substitution.   
%  The substitution $\Restrict{\theta}{\overline{x}}$ is defined 
%  as the one obtained by removing $u/x$ (for some $u$) from $\theta$. 
%  
%  Let $t$ be a term of $\LAMBDA$, which is the labeled tree $(T_t,\phi_t)$,
%  and $\theta$ be $\{u_1/x_1,\ldots,u_n/x_n\}$, where each $u_i$ is $(T_{u_i},\phi_{u_i})$. 
%  Then the term $t[\theta]$ is $(T,\phi)$, where 
%  $T = T_t \cup \{l\conc m \mid \text{$\phi_t(l) = x_i \in \FV(t)$ and $m\in T_{u_i} $}\}$.
%  For each $l\conc m$ in the latter part, $\phi(l\conc m) = \phi_{u_i}(m)$.  
%  For $l\in T_t$, we inductively define $\phi(l)$ and
%  $\theta_l$ (such that $\theta_l = \theta',\theta_{ren}$, where $\theta'\subseteq \theta$ and $\theta_{ren}$ is a renaming) as follows. 
%  \begin{itemize}
%  \item
%    $\theta_{\nil} = \theta$.
%  \item
%    If $\phi_t(l) = y^T \not\in\FV(t)$, then $\phi(l) = \theta_l(y^T)$.
%  \item
%    If $\phi_t(l) = 0$, then $\phi(l) = 0$. 
%  \item    
%    If $\phi_t(l) = \Succ$, then $\phi(l) = \Succ$ and $\theta_{l\conc (1)} = \theta_l$. 
%  \item    
%    If $\phi_t(l) \in \{\ap,\cond\}$, then $\phi(l) = \phi_t(l)$
%    and $\theta_{l\conc (1)} = \theta_{l\conc(2)} = \theta_l$.
%  \item
%    If $\phi_t(l) = \lambda z^T.$ and $z\not\in\FV(\vec{u})$,
%    then $\phi(l) = \lambda z^T.$ and $\theta_{l\conc(1)} = \Restrict{(\theta_l)}{\overline{z}}$. 
%  \item
%    If $\phi_t(l) = \lambda z^T.$ and $z\in\FV(\vec{u})$,
%    then $\phi(l) = \lambda z'^T.$ and $\theta_{l\conc(1)} = \Restrict{(\theta_l)}{\overline{z}},z'/z$, where $z'$ is the least variable such that $z' \not\in \FV(t\restr l\conc(1),\vec{u})$.
%  \end{itemize}
%  We often abbreviate $t[\{u_1/x_1,\ldots,u_n/x_n\}]$ by $t[u_1/x_1,\ldots,u_n/x_n]$.
%  For a context $\Gamma = (x_1:A_1,\ldots,x_n:A_n)$ and a renaming $\theta$,
%  we write $\Gamma[\theta]$ for $(\theta(x_1):A_1,\ldots,\theta(x_n):A_n)$ if it is a context. 
%\end{definition}
%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%
% 14:47 01/04/2025
%
% Apparently, the Substitution Lemma is never used while
% proving the results of our MFPS 25 paper.
% So I crossed it out
%%%%%%%%%%%%%%%%
%
%We have the following Substitution Lemma. 
%
%\begin{lemma}[Substitution lemma]\label{lem:subst}
%Assume $t, u \in \LAMBDA$ and $x$, $y$ are variables. 
%If $x\not\in\FV(v)$ then $t[u/x][v/y]$ and $ t[v/y][u[v/y]/x]$ are 
%$\alpha$-equivalent. 
%\end{lemma}
%%%%%%%%%%%%%%%%

\subsection{Typing rules}
We define typing rules for terms of $\LAMBDA$ 
and the subset $\WTyped$ of well-typed terms.
The typing rules are similar to those of the usual simply typed $\lambda$-calculi
with natural number types (though ours are for possibly infinite terms),
except for the rules for $\cond$ and $\ap$. 
The typing rule for $\cond(a,f)$ reflects the computational meaning of $\cond$,
which is a function $\N\rightarrow A$ that returns $a$ for the input $0$,
and returns $f(t)$ for an input $\Suc{t}$. 
The typing rule for $\ap(t,u)$ is split into two sub-rules,
$\apvar$ and $\apnotvar$ depending on whether $u$ is a variable or not. 
This is for the traces and the global trace condition for $\LAMBDA$ that will be defined later. 
We will explain the rules for $\ap$ in more detail after the definition of GTC. 

%% [The following part will be put in the later section]
%% %the conditional binder $\cond$, and for 
%% the \emph{typing rule for applications} $t(u)$, which we split the rule into two sub-rules, $\apvar$
%% and $\apnotvar$, according to whether $u$ is a variable or is not a variable.
%% %$\apvar$ corresponds to an $\eta$-expansion and it introduces a global variable name $x^T$
%% %for the first argument of $t$. 
%% %As we said, 
%% We need to consider apart the case $t(x)$ of application of $t$ to a variable
%% $x$, because in this case we will also check, using the Global Trace Condition, 
%% whether the first argument of $t$ is infinitely decreasing in any infinite 
%% computation. If this is the case, then no infinite computation exists. $\apvar$ is like 
%% a mark \quotationMarks{to be observed} for the argument $x$ of $t(x)$,
%% it helps to automatically discover a part of the terminating functions.

%% Remark that we introduced a unique \emph{term notation $\ap$} for application: 
%% we write $\ap(t,u)$ no matter if $u$ is a variable or not, while we split 
%% the typing rule for $\ap$ into two sub-cases. 


\begin{definition}(Typing rules of $\LAMBDA$)
%Assume $\Gamma = {x_1}^{A_1}:A_1, \ldots, x_n^{A_n}:A_1$ is a context. 
Let $p=0,1,2$.
%$\Delta = y_1:B_1, \ldots, y_n:B_m$ are sequents of length $n$, $m$ respectively. Suppose
%$f:\{1, \ldots, n\} \rightarrow \{1, \ldots, m\}$ is any injection, compatible with types
%in $\Gamma$, $\Delta$: we assume $A_i = B_{f(i)}$ for all $1 \le i \le n$.

\begin{enumerate}
%\item
%$\struct_f$-rule.
%If $t: \Gamma \vdash T$ then $t[ y_{f(1)}/x_1, \ldots,  y_{f(p)}/x_p]:\Delta \vdash T$
\item
We list the typing rules for $\LAMBDA$.

\begin{enumerate}
\item
$\weak$-rule (for Weakening + Exchange).
If $\Gamma \vdash t:T$ and $\FV(\Gamma) \subseteq \FV(\Gamma')$,
then $\Gamma' \vdash t : T$.

\item
$\var$-rule.
If $x^A \in \FV(\Gamma)$, then $\Gamma \vdash x^A:A$.

\item
$\lambda$-rule.
If $\Gamma\setminus \{x^A:A\}, x^A:A \vdash b: B$,
then $ \Gamma \vdash \lambda x^A.b :A \rightarrow B$.

\item
$\apvar$-rule.
If $\Gamma \vdash f: A \rightarrow B$, then $\Gamma \vdash f(x^A) :  B$,
provided  $x^A \in \FV(\Gamma)$.

\item
$\apnotvar$-rule.
If $\Gamma \vdash f:A \rightarrow B$ and $\Gamma \vdash a:A$
then $\Gamma \vdash f(a) : B$, provided $a$ is \emph{not} a variable. 

\item
$0$-rule.
$\Gamma \vdash 0: \N$ holds without any premises. 

\item
$\Succ$-rule.
If $\Gamma \vdash t:\N$ then $\Gamma \vdash \Succ (t):\N$.

\item
$\cond$-rule.
If $\Gamma \vdash  a :A$ and  $\Gamma \vdash f : \N \rightarrow A$ 
then $\Gamma \vdash \cond(a,f) : \N \rightarrow A$.
\end{enumerate}

%We have a single structural rule  $\struct_f$, which can be used for:
% weakening, variable permutation and variable renaming. 
%We have a a single structural rule $\weak$ for extending a context 
%$\Gamma$ to a context 
%$\Gamma' \supseteqsim \Gamma$. When $\Gamma' \sim \Gamma$ (when 
%$\Gamma'$, $\Gamma$ are permutation each other), 
%the rule $\weak$ can be used for variable permutation.
%%Variable renaming for a term $t[\vec{x}]$ can be obtained by writing 
%%$(\lambda \vec{x}.t[\vec{x}])(\vec{x'})$. 

%Therefore we do not assume having a primitive rule for renaming. 
%The lack of a renaming rule is a 
%\emph{difference with the circular syntax for inductive \underline{proofs}}.
%
%The reason of not having implicit $\alpha$-conversion mentioned in the previous section 
%comes from this assumption. 
%For example, if we identify the $\alpha$-equivalent terms $\lambda x^A.x$ and $\lambda z^A.z$,
%the left derivation is a correct proof, but the right one is not ($(z:A,z:A)$ is not a context).
%That is, the proof structure does not closed under identity of the $\alpha$-equivalence. 
%\begin{center}
%  $\infer{
%    z:A \vdash \lambda x^A.x:A\to A
%  }{
%    \infer{
%      z:A, x:A \vdash x:A
%    }{}
%  }$
%  \qquad
%  $\infer{
%    z:A \vdash \lambda z^A.z:A\to A
%  }{
%    \infer{
%      z:A, z:A \vdash z:A
%    }{}
%  }$  
%\end{center}
%The provability of sequents is closed under the variable renaming and the $\alpha$-equivalence.
%We will discuss this point later. 

%11:56 29/04/2024


An instance of a typing rule $r$ is a list $(J_1,\ldots,J_p,J)$ of typing judgments $(p=0,1,2)$,
where \emph{``$J$ is obtained from $J_1, \ldots, J_p$ by applying the rule $r$"}, and we draw it as:
 \[
  \infer[r]{
    J
  }{
    J_1
    &
    \cdots
    &
    J_p
  }.
  \]
  The judgments $J_1,\ldots,J_p$ are called the \emph{premises} of $r$,
  and $J$ is called the \emph{conclusion} of $r$. 
\end{enumerate}

The set $\Rule$ of rule instances for $\LAMBDA$ is defined by
\[
\Rule = 
\{\,r \in \Judg \cup \Judg^2 \cup \Judg^3 \mid \mbox{$r$ is an instance of some rule for $\LAMBDA$}\,\}.
\]
\end{definition}

We note that, when $x^A \not \in \FV(\Gamma)$, the $\lambda$-rule becomes:
if $\Gamma, x^A:A \vdash b: B$
then $ \Gamma  \vdash \lambda x^A.b :A \rightarrow B$.

We have $\weak$-rule as a primitive rule, even if $\weak$ could 
conditionally derived from the other rules. The reason is that it is simpler
to write examples of regular terms when we use typing rules with $\weak$.
 
%Indeed, we use $\weak$-rule to remove bound variables no more in use when 
%whenever we unfold a fixed point definition. Without $\weak$-rule, we would be 
%forced to introduce more and more fresh names for bound variables in order to 
%prevent variable capture. Eventually we would add infinitely many fresh variable 
%names, and this would destroy the regularity of the term.

%A last remark. In the $\weak$-rule, from the condition 
%$\FV(\Gamma) \subseteq \FV(\Gamma')$
%we can recover a unique map $\phi$ such that $\phi:\Gamma \rightarrow \Gamma'$.
%We will use the information in $\phi$ to state the Global Trace condition for terms
%of $\LAMBDA$.

We say that two rule instances are equal if they have the same list of judgments. 
Any rule instance different from $\weak$ can be uniquely recovered from its conclusion.

\begin{proposition}(Rules and subterms)
\label{proposition-rules-subterms}
Assume $r, r' \in \Rule$ are no instances of the $\weak$-rule 
and have the same conclusion $\Gamma \vdash t:A$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% WE CANNO INCLUDE THE weak RULE
% THE ASSUMPTIONS OF weak ARE NOT UNIQUE. 
% This is why weak is taken as a derived rule
Then $r = r'$, and if the premises of $r$ are some 
$\Gamma_1 \vdash t_1:A_1, \ldots, \Gamma_p \vdash t_p:A_p$,
then the list of immediate subterms of $t$ is exactly $(t_1, \ldots, t_p)$.
\end{proposition}

From the typing rules we define the proofs that a term is well-typed. 
%Proofs are binary trees labeled on the set $\Rule$.
%, each node is associated to a typing 
%judgment which is a consequence of the typing judgments associated to the 
%children node under some rule $r \in \Rule$ of $\LAMBDA$.

%12:55 29/04/2024

%The next definition is the formal definition of proof.
%
%We mention that we will introduce a restriction we call \emph{left-finite} on proof trees. 
%The restriction left-finite is used to prevent trivial proofs. 
%For instance, we want to forbid a proof cyclically switching the variables $x$ and $y$ in the context of a term,
%by an infinite nesting of $\weak$-rule (Weakening + Exchange  rule):
% \[
%  \infer[\weak]{
%    (x^T:T, y^U:U) \prove t : A
%  }{
%    \infer[\weak]{
%    (y^U:U,  x^T:T) \prove t : A
%  }{\infer*{}{}}
%  }
%  \]
%Another example: we want to forbid an infinite left nesting of applications, as in a proof of 
%$t_{n}:A^n \rightarrow A$ where $t_{n} = t_{n+1}(t_0)$:
% \[
%  \infer[\apnotvar]{
%   \prove t_n : A^n \rightarrow A
%  }{
%    \infer[]{
%   \prove t_{n+1} : A^{n+1} \rightarrow A
%  }{\ldots}
%   &
%   \infer[]{
%   \prove t_{0} : A
%  }{\ldots}
%  }
%  \]
%These proof trees are meaningless and should be ruled out. 

%We ask that all leftmost branches in any sub-proof are finite. 
%The idea is that when the main operation in a programming language is application, 
%then the leftmost branch uniquely  determines the type of the term and therefore it should be finite for the term to make sense.
%%12:54 03/06/2024

%DI QUI 17:35 11/06/2025 

\begin{definition}(Proofs of $\LAMBDA$)
Assume $\Pi=(T,\phi, \psi)$ is a binary tree $T$ with each node $l \in T$ 
labeled by a judgment $\phi(l) \in \Judg$ and by a rule $\psi(l) \in \Rule$. 
We denote the root of $T$ with $\nil$
and the $i$-th child, if it exists, of the node $l \in T$ with $l \conc (i)$.

Let $J$ be a judgment. 
Then we write $\Pi: J$, and we say that $\Pi$ is a proof of conclusion $J$ if:

\begin{enumerate}
\item 
  The judgment labeling the root $\nil$ of $T$ is the conclusion: $\phi(\nil) = J$.
\item
  If the judgment labeling $l \in T$ is $\phi(l) = J_0$, if $l$ has $p$ children
  and $\phi(l \conc (i)) = J_i$ for $i=1, \ldots, p$,
  then the rule instance $r = \psi(l) \in \Rule$ labeling $l$ is $(J_1,\ldots,J_p,J_0)$.
\end{enumerate}

\end{definition}

%
%We can check that a proof is left-finite if and only if all leftmost paths of all sub-proofs are finite.
%
%In the case of a regular proof, we can decide in polynomial time in the number of sub-proofs whether a
%proof is left-finite. Here is the algorithm. Suppose a possibly infinite proof has $n$ subproofs.
%For each sub-proof we follow the leftmost path, after $n$ steps either we reach some rule without
%premises (either a $\var$-rule or a $0$-rule), or we loop. Then:
%\begin{enumerate}
%\item
%If for all sub-proofs we stop then the proof is left-finite
%\item
%If for some sub-proof we loop, then there is infinite leftmost path and the proof is \emph{not} left-finite.
%\end{enumerate}
%We estimate the computation time to $O(n)$ for each of the $n$ sub-proofs, 
%and the total computation time to $O(n^2)$.
%\\

There are non-sensical typing proofs. For example, assume $t_n = t_{n+1}(0)$ is
a term family indexed on $n \in \Nat$. Then, for any type $A$, we can define a proof family
$\Pi_n:\ \vdash t_n : \N^n \rightarrow A$ whose conclusion is obtained by
$\Pi_{n+1} :\ \vdash t_{n+1} : \N^{n+1} \rightarrow A$ and
and $\Pi:\ \vdash 0:\N$. 
There is no obvious interpretation for the term $t_0$, 
since it can have type $A$, which is arbitrary taken. 

For this reason, we say that a term $t$
is well-typed if $\Pi:\Gamma \vdash t:A$ for some proof-tree $\Pi$ satisfying one extra 
condition, \emph{left-finiteness}, used to remove some non-sensical proofs like above.

\begin{definition}(Well-typed term of $\LAMBDA$)
%\mbox{}
\begin{enumerate}

\item
A path $\pi$ in a proof $\Pi=(T,\phi,\psi)$ is any finite non-empty 
or infinite sequence of nodes of $T$,
with first node of $\pi$ the root of $T$, 
and each other node of $\pi$ a child of the previous node in $\pi$.

\item
A path is \emph{left-finite} if only finitely many nodes of $\pi$
are left-child, where a left-child node is the left child of its parent.

\item
A proof $\Pi$ is \emph{left-finite} if all paths $\pi$ in $\Pi$ are left-finite.

\item
A term $t$ is \emph{well-typed} if and only if $\Pi:\Gamma \vdash t:A$ 
for some left-finite proof $\Pi$ with $\FV(\Gamma) \supseteq \FV(t)$.

\item
$\WTyped \subseteq \LAMBDA$ is the set of well-typed terms.

\end{enumerate}

%A proof $\Pi:\Gamma \vdash  t :T$ is canonical if all $\weak$-rules
%\begin{enumerate}
%\item
% either follow some $\lambda$-rule for a term $\lambda x^T.b$, and they introduce $x^T$ in the context,
%\item
%or follow some $\cond$-rule for a term $\cond(f,g)$, and and they introduce $x^\N$ in the context,
%\end{enumerate}

\end{definition}

\begin{proposition}
Well-typed terms are closed by well-typed substitution:
if $\Pi_1: x^U:U, \Gamma \vdash t:A$ and $\Pi_2: \Gamma \vdash u:U$
are left-finite proofs,
then $\Pi:\Gamma \vdash t[u/x^U]:A$ for some left-finite proof $\Pi$.
\end{proposition}

%
%Proofs not using the $\weak$-rule are unique, because the first symbol of each 
%subterm forces the rule deriving this subterm. If we add the $\weak$-rule, this is 
%no more true. However, 
%

We can prove the \emph{uniqueness} of type for a well-typed term. 

%12:25 13/06/2025

\begin{proposition}(Uniqueness of Typing)
\label{proposition-left-finite-unique}
If both $\Pi:\Gamma \vdash t:A$ and $\Pi':\Gamma' \vdash t:A'$ are two left-finite proofs,
then $A = A'$.
\end{proposition}

%
%%08:56 19/06/2024
%\begin{proof}
%By induction on the sum of the length of the leftmost branch in $\Pi$ and $\Pi'$. These lengths are finite
%because $\Pi$ and $\Pi'$ are assumed to be left-finite. Let $r$ be the last rule of $\Pi$ and $r'$ be the
%last rule of $\Pi'$.
%\begin{enumerate}
%\item
%Assume $r = \weak$. Then $\Pi$ is obtained from a proof $\Pi_1:\Gamma_1 \vdash t:A$. 
%By induction hypothesis on $\Pi_1$ and $\Pi'$ we conclude that $A = A'$.
%
%\item
%Assume $r \not = \weak$ and $r' = \weak$. 
%Then $\Pi'$ is obtained from a proof $\Pi'_1:\Gamma_1 \vdash t:A$. 
%By induction hypothesis on $\Pi$ and $\Pi'_1$ we conclude that $A = A'$.
%
%\item
%Assume  $r \not = \weak$ and $r' \not = \weak$. Then both $r$ and $r'$ are the typing rule for
%the outermost constructor of $t$ and for some
%$h=0,1,2$ the proof $\Pi$ has premises $\Pi_1, \ldots, \Pi_h$
%and the proof $\Pi'$ has premises $\Pi'_1, \ldots, \Pi'_h$ (for the same $h$). 
%We distinguish one case for each constructor.
%
%\begin{enumerate}
%\item
%Assume $t = x^T$. Then $r=r'=\var$-rule and $A = A' = T$.
%
%\item
%Assume $t =0^\N$. Then $r=r'=0$-rule and $A = A' = \N$.
%
%\item
%Assume $t =\Succ(u)$. Then $r=r'=\Succ$-rule  and $\Pi_1:\Gamma \vdash u: \N$
%and $\Pi_2:\Gamma' \vdash u:\N$ and $A = A' = \N$.
%
%\item
%Assume $t = f(u)$. Then $r=r'=\ap$-rule and $\Pi_1:\Gamma \vdash f:U \rightarrow A$
%and $\Pi_2:\Gamma' \vdash f:U' \rightarrow A'$. By induction hypothesis on $\Pi_1$ and
%$\Pi'_1$ we deduce that $(U \rightarrow A) = (U' \rightarrow A')$, in particular that $A = A'$.
%
%\item
%Assume $t = \lambda x^T.b$. Then $r=r'=\lambda$-rule and 
%$\Pi_1:\Gamma \vdash b:B$
%and $\Pi_2:\Gamma' \vdash b:B'$. By induction hypothesis on $\Pi_1$ and
%$\Pi'_1$ we deduce that $B=B'$, in particular that $A = T \rightarrow B = T \rightarrow B' = A'$.
%
%\item
%Assume $t = \cond(f,g)$. Then $r=r'=\cond$-rule and $\Pi_1:\Gamma \vdash f:A$
%and $\Pi_2:\Gamma' \vdash f:A'$. By induction hypothesis on $\Pi_1$ and
%$\Pi'_1$ we deduce that $A = A'$.
%
%\end{enumerate}
%\end{enumerate}
%\end{proof}

%
%We provide some examples of well-typed and not well-typed terms.
%%23:30 23/04/2024
%Some term in $\LAMBDA$ has no type, like the application $0(0)$ of the non-function $0$. 
%
%\begin{Eg}
%We provide a term in $\LAMBDA$ having more than one type.
%Let $t=u(0)$ and $u=\cond(t,u)$. $t$ has an infinite lefmost branch $t,u,t,u, \ldots$, therefore
%$t$ is not left-finite and it has no \emph{left-finite typing proof}.
%Unicity fails and we can prove $\vdash t:A$ for all types $A \in \Type$. 
%The subterms of $t$ are $\{t, u, 0\}$ and a proof $\Pi: \emptyset \vdash t:A$ is
%\[
%\infer[\apnotvar]{
%  \prove t : A
%}{
%  \infer[\cond]{
%    \prove u:\N \rightarrow A
%  }{
%    \infer*{
%      \prove t : A
%    }{}
%    &
%    \quad
%    &
%    \infer*{
%      \prove u : \N \rightarrow A
%    }{} 
%  }
%  &
%  \quad
%  &
%  \infer[0]{
%    \prove 0:\N
%  }{}
%}
%\]
%Formally, the typing proof $\Pi=(T,\phi):\vdash t:A$ 
%is defined by $\universe{\Pi}=\universe{t}$ and:
%\begin{enumerate}
%\item
%$\Label(\Pi,l)=(\vdash A)$ \ \ \ \ \ \ \ for all $l \in \universe{t}$ such that  $t \restr l = t$,
%\item
%$\Label(\Pi,l) = (\vdash \N \rightarrow A)$  for all $l \in \universe{t}$ such that $t \restr l = u$,
%\item
% $\Label(\Pi,l)=(\vdash\N)$ \ \ \ \ \ \ \  for all $l \in \universe{t}$ such that $t \restr l = 0$. 
%\end{enumerate}
%%09:06 24/04/2024
%\end{Eg}
%
%
%A term with at least two types has the leftmost branch infinite, as it is the case for $t$ above.
%We proved that if \emph{all} subterms of a term have the leftmost branch finite, then the term 
%has at most one type.
%
%
%\emph{Claim (existence of a polynomial-time typing algorithm)}.
%We claim without proof that if a term $t$ is regular then we can decide if an left-finite proof 
%$\Pi:\Gamma \vdash A$ exists. If an left-finite proof $\Pi$ exists 
%then at least one of left-finite proofs is regular and we can compute it. 
%We first check whether the term is left-finite in time $O(n^2)$. If it is not we reject the term.
%Otherwise we start the standard recursive typing algorithm, until a type has been inferred consistently
%for each of the finitely many subterms, or some type inconsistency has been found.
%In the first case we accept the term and we return the time, in the second case we reject the term
%and we return no type.
%The computation requires quadratic time in the size of the graph representing the term.


%10:26 20/04/2024
%13:49 29/04/2024
%12:20 27/03/2025

\subsection{Reduction rules}
Our goal is to provide a set of well-formed term for $\LAMBDA$ and interpret 
them as partial functionals, a semantics for circular $\lambda$-terms.
Some terms of $\LAMBDA$, those satisfying the global trace condition 
(to be introduced later) will denote a subset of the total 
functionals. Our first step is to provide reduction rules for $\LAMBDA$.

%18:14 27/03/2024


\begin{definition}(Reduction Rules for $\LAMBDA$)
  Let $a$, $b$, $f$, $g$, $t$, and $u$ be in $\LAMBDA$.
  We first define the binary relations $\reduces_\beta$ and $\reduces_\cond$ as follows.
\begin{enumerate}
\item
$\reduces_\beta$: $(\lambda x^A.b)(a) \reduces_\beta b[a/x]$
\item 
$\reduces_\cond$:
$\cond(f,g)(0) \reduces_\cond f$ and
$\cond(f,g)(\Succ (t)) \reduces_\cond g(t)$.
\end{enumerate}

A \emph{redex} is a term in the shape of the term at the left-hand side of $\reduces_\beta$ or $\reduces_\cond$. 
The \emph{one-step reduction relation} $\reduces$
is the contraction of one $\beta$ or of one $\cond$ redex anywhere
in the term, namely,
it is the union of the context closures of $\reduces_\beta$ and $\reduces_\cond$.
The relation $\reduces^*$ is the reflexive and 
transitive closure of $\reduces$ (zero or more reductions).
The relation $\reduces^{+}$ is the 
transitive closure of $\reduces$ (one or more reductions).

%$a \sim b$ is the existence of a common reduct: 
%$\exists c \in \LAMBDA. (a \reduces^* c) \wedge (b \reduces^* c)$.

The $\cond$-depth of a subterm $u$ of $t$ is 
the number of edges between a $\cond$ node and its right child on the path
from the root of $t$ to the root of $u$. 
The $n$-safe level of $t$ is the set of nodes of $t$ with $\cond$-depth $\le n$.

We say that $t \nsafeReduces{n} u$, or that $t$ $n$-safely reduces to $u$,  
if we reduce $t$ to $u$ by contracting a single redex in the $n$-safe level of $t$ 
(i.e. of $\cond$-depth $\le n$).
%We call \emph{unsafe} a reduction inside any $\cond(f,g)$.
A term is $n$-safe-normal if all its redexes (if any) have $\cond$-depth $>n$.

We abbreviate \quotationMarks{$t$ is $0$-safe normal} 
with just \quotationMarks{$t$ is safe normal}.
\end{definition}

%09:19 24/04/2024
%14:00 29/04/2024

\begin{Eg}
Let $u \sim \cond(0, (\lambda z.u)(z) )$, where we omitted the type superscript
$\N$ of $z$. Then $u$ is $0$-safe-normal (safe normal for short), 
because all redexes in $u$ are of the form  $(\lambda z.u)(z)$ and are in the right-
hand-side of a $\cond$. However $u$ has infinitely many nodes which are $\beta$-
redexes. Up to tree isomorphism, the tree form of $u$ includes the following branch:
\begin{center}
  $u$, 
  \quad
  $(\lambda z.u)(z)$, 
  \quad
  $\lambda z.u$, 
 \quad
  $u$, 
 \quad $\ldots$
\end{center}
This infinite branch is cyclic,
and includes infinitely many $\beta$-redexes.
%all isomorphic to the same term $(\lambda z.u)(z)$. 
It takes infinitely many $\beta$-reductions to normalize $t$,
therefore $u$ has no normal form.
\end{Eg}

In order to produce the output of a computation we have
to reduce closed terms of type $\N$ to a numeral. 
We will define a subset $\CTlambda$ of
$\LAMBDA$ and prove that if we repeat $0$-safe reductions 
(those in the right-hand side of \emph{no} $\cond$) on any
closed term of type $\N$ of $\CTlambda$ eventually we obtain a numeral. 
We will in fact prove that the $0$-safe reduction relation is strongly normalizable on \emph{any} term
of $\CTlambda$. 

%14:11 25/03/2025

\begin{Eg}
This is an example of $0$-safe-reductions from a term $v(n)$ to a normal form. 
Assume $n \in \Num$ is any numeral and $v \sim \cond(1, v)$. There are only finitely 
many reductions from $v(n)$, and they are all $0$-safe. The initial term $v(n)$ $\cond$-reduces to 
$v(n-1)$, then we loop: $v(n-1)$ $\cond$-reduces to $v(n-2)$ and so forth.
After $n$ $\cond$-reductions we get $v(0)$. With one last $\cond$-reduction we 
get $1$ and we stop. Thus, the term $v(n)$ strongly normalizes (the reduction path is unique)
to $1$ in $(n+1)$ steps.
%$v(n)$ has a unique reduction path,
%having length $(n+1)$ and terminating in $1$.
The final output is independent from $n$.
\end{Eg}

We will exhibit meaningful terms of $\CTlambda$ without a normal form. 
However, for those terms we will define \quotationMarks{a limit normal form},
in a sense we will make precise.
