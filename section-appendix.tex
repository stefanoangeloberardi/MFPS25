\section{Appendix}
We include here all proofs for the statements of our paper and one more example,
the Ackermann function.

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION 1
% introduction 
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% no proofs to be included

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION 2
% infinite lambda terms
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\begin{proposition}[Uniqueness of left-finite type]
%\label{proposition-left-finite-unique}
%If $t \in \LAMBDA$, $\Pi:\Gamma \vdash t:A$ and  $\Pi':\Gamma' \vdash t:A'$ are two left-finite
%proofs then $A = A'$.
%\end{proposition}

%08:56 19/06/2024
\begin{proof}(Uniqueness of Typing, 
Prop. \ref{proposition-left-finite-unique})
By induction on the sum of the length of the leftmost branch in $\Pi$ and $\Pi'$. These lengths 
are finite because $\Pi$ and $\Pi'$ are assumed to be left-finite. Let $r$ be the last rule of $\Pi$ 
and $r'$ be the last rule of $\Pi'$.
\begin{enumerate}
\item
Assume $r = \weak$. Then $\Pi$ is obtained from a proof $\Pi_1:\Gamma_1 \vdash t:A$. 
By induction hypothesis on $\Pi_1$ and $\Pi'$ we conclude that $A = A'$.

\item
Assume $r \not = \weak$ and $r' = \weak$. 
Then $\Pi'$ is obtained from a proof $\Pi'_1:\Gamma_1 \vdash t:A$. 
By induction hypothesis on $\Pi$ and $\Pi'_1$ we conclude that $A = A'$.

\item
Assume  $r \not = \weak$ and $r' \not = \weak$. Then both $r$ and $r'$ are the typing rule for the label of the root of $t$, for some
$h=0,1,2$ the proof $\Pi$ has premises $\Pi_1, \ldots, \Pi_h$,
and the proof $\Pi'$ has premises $\Pi'_1, \ldots, \Pi'_h$ for the same $h$. 
We distinguish one case for each possible label of the root of $t$.

\begin{enumerate}
\item
Assume $t = x^T$. Then $r=r'=\var$-rule and $A = A' = T$.

\item
Assume $t =0^\N$. Then $r=r'=0$-rule and $A = A' = \N$.

\item
Assume $t =\Succ(u)$. Then $r=r'=\Succ$-rule  and $\Pi_1:\Gamma \vdash u: \N$
and $\Pi_1:\Gamma' \vdash u:\N$ and $A = A' = \N$.

\item
Assume $t = f(u)$. Then $r=r'=\apvar$-rule or $r=r'=\apnotvar$-rule .
In both cases we have $\Pi_1:\Gamma \vdash f:U \rightarrow A$
and $\Pi_1:\Gamma' \vdash f:U' \rightarrow A'$. By induction hypothesis on 
$\Pi_1$ and $\Pi'_1$ we deduce that $(U \rightarrow A) = (U' \rightarrow A')$, 
in particular that $A = A'$.

\item
Assume $t = \lambda x^T.b$. Then $r=r'=\lambda$-rule and 
$\Pi_1:\Gamma\setminus\{x^T:T\}, x^T \vdash b:B$ and 
$\Pi'_1:\Gamma'\setminus\{x^T:T\}, x^T \vdash b:B'$. 
By induction hypothesis on $\Pi_1$ and $\Pi'_1$ we deduce that $B=B'$, in particular that $A = (T \rightarrow B) = (T \rightarrow B') = A'$.

\item
Assume $t = \cond(f,g)$. Then $r=r'=\cond$-rule and $\Pi_1:\Gamma \vdash f:A$
and $\Pi'_1:\Gamma' \vdash f:A'$ by definition of $\cond$-rule with conclusion
$A$. By induction hypothesis on $\Pi_1$ and
$\Pi'_1$ we deduce that $A = A'$.

\end{enumerate}
\end{enumerate}
\end{proof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION 3
% trace
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% there are no proofs

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION 4
% CT-lambda
%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\begin{proposition}(The iterator map $\Iter$ is a term of $\CTlambda$)
%\label{proposition-iterator-in-CT-lambda}
%$\Iter \in \Reg \cap \WTyped \cap \GTC = \CTlambda$.
%\end{proposition}

\begin{proof}
(The iterator map $\Iter$ is a term of $\CTlambda$, 
Prop. \ref{proposition-iterator-in-CT-lambda})
The term $\Iter$ is well-typed and regular by definition. 
We check the global trace condition. 

We follow the unique infinite path $\pi$ of $\Iter$, looking for an
infinitely progressing trace $\tau$. 
The only way to obtain an infinite path $\pi$ is to loop
from $\iter$ to $\iter$.
So, $\pi$ moves from  $\Iter = \lambda f. \lambda a.\iter$
to $\lambda a.\iter$, then to $\iter = \cond (a, \lambda x.f(\iter(x)))$.
Then the infinite path $\pi$ moves in this order to:
 $\lambda x.f(\iter(x))$, $f(\iter(x))$, $ \iter(x)$, $\iter$, cyclically.
 
We choose the unique infinite trace $\tau$ of $\pi$ starting from the first unnamed argument of $\iter$. $\tau$, being infinite, must move
 from $\cond$ to the second argument 
$\lambda x.f(\iter(x))$ of $\cond$, then moves to $x$ in the context of 
$f(\iter(x))$, then to $x$ in the context $\iter(x)$. Eventually $x$ is erased
by a $\weak$-rule, so $\tau$ must move from $x$ 
to the first unnamed argument of $\iter$ again, looping from $\iter$ to $\iter$. 
At each loop the trace $\tau$ 
progresses once. We conclude that $\tau$ is an infinitely progressing 
trace of $\pi$.
\end{proof}


%\begin{proposition}
%(The interval map $\Interval$ is a term of $\CTlambda$, Prop. \ref{proposition-interval-in-CT-lambda})
%$\Interval \in \Reg \cap \WTyped \cap \GTC = \CTlambda$.
%\end{proposition}

\begin{proof}(The interval map $\Interval$ is a term of $\CTlambda$, Prop. \ref{proposition-interval-in-CT-lambda})
The term $\Interval$ is well-typed and regular by definition. We check the global trace condition.
Any infinite path $\pi$ either moves to $\iter$, 
for which we already checked the global trace condition,
or cyclically moves from $\interval; \N,\N \rightarrow \alpha$ to $\interval$
itself. We follow the unique infinite 
trace $\tau$ from the last unnamed argument $\N$ of $\interval$ 
inside the infinite path $\pi$ cyclically moving from $\interval$ to $\interval$.
%19:53 01/04/2025
The trace $\tau$ moves to the last unnamed argument $\N$ of  
$\interval:\N,\N \rightarrow \alpha$, then to the last unnamed argument of
$\cond (\ [\iter(x)],  \  \lambda y.\iter(x) @ (\lambda x.\interval)(\Succ(x))(y) \ )$.
In this step $\tau$ progresses, and moves to 
the first unnamed argument of $\lambda y.\iter(x) @ (\lambda x.\interval)(\Succ(x))(y) \ )$,
then to $y:\N$ in the context of $\iter(x) @ (\lambda x.\interval)(\Succ(x))(y))$.
After one $\apnotvar$ rule, the trace $\tau$ reaches $y:\N$ in the context of
$(\lambda x.\interval)(\Succ(x))(y)$.
Then after one $\apvar$ rule, 
the trace $\tau$ moves from $y:\N$ to the unique unnamed argument of 
$(\lambda x.\interval)(\Succ(x))$, 
then to the last unnamed argument of $\interval$. 
From $\interval$ the trace $\tau$ loops. 
Each time $\tau$ moves from $\interval$ to $\interval$
then $\tau$ progresses once. We conclude that $\tau$ infinitely progresses.
\end{proof}
%14:27 24/04/2024



%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 5
%% subject reduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%\newcommand{\xx}{\boldsymbol{x}}
%
%\subsection{Proof of Subject Reduction for Well-Typed Infinite Lambda Terms}
%\label{subsection-subject-reduction}
%
%We show the subject reduction for well-typed terms of $\LAMBDA$,
%and also show the global trace condition is preserved by reductions. 
%We first introduce some auxiliary notations for proofs of them.
%
%Assume $\Pi:\Gamma \vdash t:A$ is any typing proof, $\alpha$ any node of
%$\Pi$ and $\Delta \vdash u:A$ the sequent of $\alpha$ in $\Pi$. Then a variable
%$x \in \FV(\Delta)$ is local in $\Pi, \alpha$ if and only if there is some ancestor
%$\beta < \alpha$ whose sequent is some $\lambda x.v$. 
%$x$ is global if and only if $x$ is not local. $x$ is effectively occurring in 
%$\Pi, \alpha$ if and only $x \in \FV(u)$.
%A substitution on $t$ only act on global variables. A trace is local if and only if all 
%its named arguments are local, it is effectively occurring if and only if all its 
%named arguments are effectively occurring.
%
%We can prove that if a trace is progressing, then from the first progress point all 
%named arguments $x$ of the trace are local variables. This means that if we 
%remove all elements of a trace before the first progress point we are left with a 
%local trace, and all infinitely progressing trace have a local suffix with the same 
%progress points. Thus, $\Pi:\Gamma \vdash t:A$ satisfies the global trace 
%condition if and only if all infinite paths of $\Pi$ have some local infinitely 
%progressing trace. In fact we can ask more: all infinite paths of $\Pi$ have some 
%local and effectively occurring infinitely progressing trace.
%
%%Let $X$ be a set of variables of the form $x^T$.
%%We write $\Gamma_X$ for the sublist of $\Gamma$ consisting of all $x^T:T$ such that $x^T\in X$. 
%%Let $\Gamma$ and $\Delta$ be contexts of $\LAMBDA$.
%%A merging of $\Gamma$ and $\Delta$ is any enumeration of 
%%$\FV(\Gamma) \cup \FV(\Delta)$.
%%The canonical choice $\mergeCtx{\Gamma}{\Delta}$ for the merged context 
%%is defined by $\Gamma\conc(\Delta_{\FV(\Delta)\setminus\FV(\Gamma)})$. 
%
%Substitution requires renaming in order to avoid variable capture.
%In the case of regular
%terms, we can rename while \emph{preserving the finiteness of the graph 
%denotation} for the term.
%
%Let $\theta$ be any renaming, i.e., an injection $:\Var \rightarrow \Var$ with
%$\Var$ the set of all variables of $\LAMBDA$.
%Given $\theta$, we can define a correspondence between
%$\N$-arguments of  two sequents
%$S_1 = \Gamma_1\vdash t_1:\vec{B_1}\rightarrow N$
%and $S_2 = \Gamma_2[\theta]\vdash t_2[\theta]:\vec{B_2}\rightarrow N$,
%as follows.
%
%Let $k_1$ and $k_2$ be indexes of $N$-arguments of $S_1$ and $S_2$, 
%respectively. 
%Then we write $(k_1,S_1) \simIndex{\theta} (k_2,S_2)$ (or $(k_1,t_1) 
%\simIndex{\theta} (k_2,t_2)$ for short)
%if $k_1$ and $k_2$ are respectively indexes of named arguments for some 
%$y \in \FV(t_1)$ 
%and $\theta(y) \in \theta(\FV(t_2))$, or
%are respectively those of unnamed arguments at the same position $i$ in $
%\vec{B_1}$ and $\vec{B_2}$,
%namely if $k_1=|\Gamma_1|+i$ and $k_2=|\Gamma_2|+i$,
%where $|\Gamma_1|$ and $|\Gamma_2|$ are the sizes of $\Gamma_1$ 
%and $\Gamma_2$. 
%Note that the index equivalent to $k_1$ is unique (if it exists), namely 
%$(k_1,t_1) \simIndex{\theta} (k_2,t_2)$ and $(k_1,t_1) \simIndex{\theta} (k'_2,t_2)$ implies $k_2=k'_2$.
%%We write $(k_1,t_1) \simIndex{} (k_2,t_2)$ if $\theta$ is the identity renaming. 
%We say that two paths $\pi_1$ and $\pi_2$
%are in correspondence in two proofs $\Pi_1$ and $\Pi_2$ of the two sequents
%$S_1$ and $S_1$ if they are equal after skipping all $\weak$-steps.
%We say that two traces $\tau_1$ in $\pi_1$ and $\tau_2$ in $\pi_2$
%are in correspondence if $\pi_1$ and $\pi_2$ are in correspondence and 
%$\tau_1$ and $\tau_2$ have the same indexes after skipping all $\weak$-steps.
%%In this paper we do not implicitly identify $\alpha$-equivalent terms,
%%in order to make simpler to state the global trace condition.
%%For this reason, 
%Proofs of this section requires some delicate treatment of variables.
%
%%We consider the following restricted $\lambda$ rule (called $\lambda'$) in which 
%%the context $\Gamma$ is minimum:
%%\begin{itemize}
%%\item
%%  $\lambda'$-rule.
%%  If $\Gamma, x^A:A \vdash b: B$ and $\FV(\Gamma) = \FV(\lambda x.b)$, 
%%  then $ \Gamma \vdash \lambda x^A.b :A \rightarrow B$.
%%\end{itemize}
%
%The next lemma says that if $\Gamma\vdash t:A$ is provable,
%then $\Delta\vdash t:A$ has a unique $\weak$-free proof whenever 
%$\FV(t) \subseteq \FV(\Delta)$.
%
%\begin{lemma}[Thinning]
%  \label{lem:thinning}
%  Assume $\Pi:\Gamma\vdash t:A$ and $\FV(t) \subseteq \FV(\Delta)$.
%  Then $\Pi':\Delta \vdash t:A$ for a unique $\weak$-free
%  proof $\Pi'$.
%  
%  Moreover if the global trace condition holds for $\Pi$, 
%  then it also holds for $\Pi'$. 
%\end{lemma}
%
%%07:40 02/04/2025
%
%\begin{proof}
%  First we call the following admissible rule $\lambda'\weak$:
%  \begin{itemize}
%  \item
%    $\lambda'\weak$-rule.
%    If $\Gamma, x^A:A \vdash b: B$, $\FV(\Gamma) = \FV(\lambda x.b)$ and $\Gamma\subseteqsim \Gamma'$, 
%    then $ \Gamma' \vdash \lambda x^A.b :A \rightarrow B$.
%  \end{itemize}
%  We write $\Rule'$ as the set of rule instances obtained by removing
%  those of $\lambda$ from $\Rule$ and adding those of $\lambda'\weak$. 
%  Note that if we have a proof of a sequent with $\lambda'\weak$,
%  then we also have a proof of the same sequent not with $\lambda'\weak$
%  by a proof transformation that splits each $\lambda'\weak$ by $\lambda'$ and $\weak$. 
%  Also note that this proof transformation preserves the global trace condition.
%
%  Let $\Pi$ be $(T,\phi)$.
%  For each $l \in T$, we write $\Gamma_l\vdash t_l:A_l$
%  for the conclusion of $\phi(l) \in \Rule$. 
%  To show the lemma, from a given proof $\Pi$, 
%  it is enough to construct a proof $\Pi'$ of $\Restrict{\Gamma}{\FV(t)}\vdash t:A$ with $\Rule'$.
%  
%  We define the set of nodes of $\Pi'$ is $T$, which is the same one of $\Pi$. 
%  For each $l\in T$, we define $\phi'(l)$ and $\Gamma'_l$ that satisfies
%  the following requirements:
%  \begin{itemize}
%  \item[(a)]
%    $\Gamma'_l\vdash t_l:A_l$ is the conclusion of $\phi'(l) \in \Rule'$,
%  \item[(b)]
%    $\Restrict{(\Gamma_l)}{\FV(t_l)} \subseteqsim \Gamma'_l \subseteqsim \Gamma_l$
%    and $\Gamma'_{\nil} = \Restrict{\Gamma}{\FV(t)}$, 
%  \item[(c)]
%    if $\tilde{k},t_{l\conc(i)}$ is the successor of $k,t_l$ in $\Pi$
%    and $k$ is an index of some unname argument
%    or a named argument of some name $z\in\FV(t_l)$, 
%    then there are $\tilde{k'}$ and $k'$ such that
%    $\tilde{k'},t_{l\conc(i)}$ is the successor of $k',t_l$ in $\Pi'$, 
%    $(k,t_l) \simIndex{} (k',t_l)$,
%    and $(\tilde{k},t_{l\conc(i)}) \simIndex{} (\tilde{k'},t_{l\conc(i)})$.
%    Moreover, if $k$ is an index of a progressing argument, then so is $k'$.
%  \end{itemize}
%  Note that the proof is done if we construct $\Pi'$ that satisfies these requirements. 
%  
%  We define $\Gamma'_{\nil} = \Restrict{\Gamma}{\FV(t)}$.
%  Then it satisfies (b) since $t_\nil = t$. 
%  Next, assuming the induction hypothesis that $\Gamma'_l$ which satisfies (b)
%  is already defined, 
%  we define $\phi'(l)$ and $\Gamma_{l\conc(i)}$, 
%  for each $i$ such that $l\conc(i)\in T$, 
%  that satisfies (a), (b), and (c). 
%  It is done by the case analysis of $\phi(l)$.
%
%  The case of $\phi(l) = \Gamma_l\vdash x:A_l$,
%  which is an instance of the rule $\var$ with $x:A_l\in\Gamma_l$. 
%  Then define $\phi'(l) = \Gamma'_l\vdash x:A_l$. This is an instance of $\var$
%  because $x:A_l \in \Restrict{(\Gamma_l)}{\FV(x)} \subseteqsim \Gamma'_l$ by (b).
%
%  The case of $\phi(l) = (\Gamma_{l\conc(1)}\vdash t_l:A_l,\Gamma_{l}\vdash t_l:A_l)$,
%  which is an instance of the rule $\weak$ with
%  $t_{l\conc(1)} = t_l$, $A_{l\conc(1)} = A_{l}$, and
%  $\Gamma_{l\conc(1)}\subseteqsim \Gamma_l$.
%  Let $\psi$ be the unique map that determines $\Gamma_{l\conc(1)}\subseteqsim \Gamma_l$.
%  Then define $\Gamma'_{l\conc(1)}$ such that
%  $\Gamma'_{l\conc(1)}\subseteqsim \Gamma'_l$ determined by
%  the induced map from $\psi$ restricting the range to $\FV(\Gamma'_l)$.
%  Note that $\FV(\Gamma'_{l\conc(1)}) = \FV(\Gamma'_l)\cap\FV(\Gamma_{l\conc(1)})$. 
%  Then it satisfies (b) since $\FV(t_l)\subseteq \FV(\Gamma'_l) \cap \FV(\Gamma_{l\conc(1)}) = \FV(\Gamma'_{l\conc(1)}) \subseteq \FV(\Gamma_{l\conc(1)})$ by (b) for $\Gamma'_l$.
%  Define $\phi'(l) = (\Gamma'_{l\conc(1)}\vdash t_l:A_l,\Gamma'_{l}\vdash t_l:A_l)$
%  as an instance of the rule $\weak$. 
%  Hence the requirement (a) holds.
%  We can also show (c): if $k$ is an index in $\Gamma_l\vdash t_l:A_l$ for a name
%  $z\in\FV(t_{l\conc(1)}) = \FV(t_l)$, then we can take an index $k'$
%  in $\Gamma'_l\vdash t_l:A_l$ for $z$ by $\FV(t_l)\subseteq\FV(\Gamma'_l)$ by (b). 
%  An index $\tilde{k'}$ for the name $z$ can be taken
%  from $\Gamma'_{l\conc(1)}\vdash t_l:A_l$
%  since $z \in \FV(t_l) \subseteq \FV(\Gamma'_{l\conc(1)})$. 
%  
%  The case of $\phi(l) = (\Gamma_l,z:C\vdash b:\vec{B}\to N, \Gamma_l\vdash\lambda z^C.b:C,\vec{B}\to N)$
%  that is an instance of the rule $\lambda$. 
%  Define $\Gamma'_{l\conc(1)} = \Restrict{(\Gamma_l)}{\FV(\lambda z.b)},z:C$ and 
%  $\phi'(l) = (\Restrict{(\Gamma_l)}{\FV(\lambda z.b)},z:C\vdash b:\vec{B}\to N, \Gamma'_l\vdash \lambda z.b:C,\vec{B}\to N)$. 
%  This is an instance of the rule $\lambda'\weak$, since $\Restrict{(\Gamma_l)}{\FV(\lambda z.b)}\subseteqsim \Gamma'_l$ by the induction hypothesis.
%  Trivially we have (a). 
%  We also have (b) by $\Restrict{(\Gamma_l,z:C)}{\FV(b)} \subseteqsim (\Restrict{(\Gamma_l)}{\FV(\lambda z.b)},z:C) \subseteqsim (\Gamma_l,z:C)$.   
%  The requirement (c) holds: 
%  if $k$ is an index of some named argument $y\in\FV(\lambda z.b)$ in $\Gamma_l$,
%  then $k'$ can be taken as the index of $y$ in $\Gamma'_l$ by (b) for $\Gamma_l$.
%  If $k$ is an index of some unnamed argument in $C,\vec{B}$,
%  then $k'$ can be taken as the index of some unnamed argument. 
%  In both cases, their successors $\tilde{k}$ and $\tilde{k'}$ are uniquely
%  determined by $k$ and $k'$, respectively. 
%  
%  The case that $\phi(l)$ is an instance of the rule $\apvar$
%  whose conclusion is $\Gamma_l\vdash f(x^B):\vec{C}\to N$ with $x:B\in \Gamma_l$.  
%  Define $\Gamma'_{l\conc(1)} = \Gamma'_l$.
%  This satisfies (b) by the induction hypothesis. 
%  Then define
%  $\phi'(l) = (\Gamma'_{l\conc(1)}\vdash f:B,\vec{C}\to N, \Gamma'_l\vdash f(x^B):\vec{C}\to N)$
%  as an instance of the rule $\apvar$. This satisfies (a). 
%  In order to show (c), 
%  take an index $k$ for $\Gamma_l\vdash f(x^B):\vec{C}\to N$, which is the one for
%  a named argument $y \in \FV(f(x^B))$ in $\Gamma_l$
%  or for some unnamed argument of $\vec{C}$. 
%  For the latter case, the indexes $\tilde{k}$, $k'$ and $\tilde{k'}$ can be taken
%  as those of the unnamed argument in $\vec{C}$ at the same position as $k$.
%  For the former case, we take $k'$ as the index for $y$ in $\Gamma'_l$.
%  In order to take $\tilde{k'}$,
%  we further have two subcases according to $\tilde{k}$: 
%  The first one is $\tilde{k}$ is the index for the same named argument as $k$, 
%  and the second one is $\tilde{k}$ is the index for the unnamed argument, namely $B=N$.
%  In both subcases, we can take the equivalent $\tilde{k'}$ to $\tilde{k}$ as we wished.
%    
%  The case that $\phi(l)$ is an instance of the rule $\apnotvar$
%  whose conclusion is $\Gamma_l\vdash f(b^B):A_l$. 
%  Define $\Gamma'_{l\conc(1)} = \Gamma'_{l\conc(2)} = \Gamma'_l$.
%  This satisfies (b) by the induction hypothesis.
%  Then define $\phi'(l) = (S_1, S_2, \Gamma'_l\vdash f(b^B):\vec{C}\to N)$,
%  where $S_1$ is $\Gamma'_{l}\vdash f:B,\vec{C}\to N$
%  and $S_2$ is $\Gamma'_{l}\vdash b:B$, as an instance of $\apnotvar$.
%  This satisfies (a).
%  In order to show (c), 
%  take an index $k$ for $\Gamma_l\vdash f(x^B):\vec{C}\to N$, which is the one for
%  a named argument $y \in \FV(f(x^B))$ in $\Gamma_l$
%  or for some unnamed argument of $\vec{C}$.
%  For the former case, the successor $\tilde{k}$ of $k$ is uniquely taken.
%  By $\FV(f(b)) \subseteq \FV(\Gamma'_l)$, the index $k'$ equivalent to $k$ is uniquely taken. 
%  Then the successor $\tilde{k'}$ of $k'$ is also taken as we wished. 
%  For the latter case, the successor $\tilde{k}$ of $k$ is uniquely taken
%  as the one for unnamed argument at the same position as $k$. 
%  Then $k'$ equivalent to $k$ is uniquely taken, and 
%  its successor $\tilde{k'}$ is also taken as we wished. 
%
%  The case that $\phi(l)$ is an instance of the rule $0$
%  whose conclusion is $\Gamma_l\vdash 0:N$. 
%  Define $\phi'(l) = \Gamma'_l\vdash 0:N$ as an instance of the rule $0$.
%  This satisfies the requirements (a), (b), and (c). 
%
%  The case that $\phi(l)$ is an instance of the rule $\Succ$
%  whose conclusion is $\Gamma_l\vdash \Succ(t_{l\conc(1)}):N$ with $A_l=N$.
%  Define $\Gamma'_{l\conc(1)} = \Gamma'_l$, and 
%  $\phi'(l) = (\Gamma'_l\vdash t_{l\conc(1)}:N, \Gamma'_l\vdash \Succ(t_{l\conc(1)}):N)$
%  as an instance of $\Succ$. They satisfy (a) and (b). 
%  The requirement (c) is also satisfied:
%  Take an index $k$ for $\Gamma_l\vdash \Succ(t_{l\conc(1)}): N$,
%  which is the one for a named argument $y \in \FV(\Succ(t_{l\conc(1)})$ in $\Gamma_l$.
%  Then the successor $\tilde{k}$ of $k$ is uniquely taken.  
%  By $\FV(t_{l\conc(1)}) \subseteq \FV(\Gamma'_l)$, the index $k'$ equivalent to $k$ is uniquely taken. 
%  Then the successor $\tilde{k'}$ of $k'$ is also taken as we wished. 
%  
%  The case that $\phi(l)$ is an instance of the rule $\cond$
%  whose conclusion is $\Gamma_l\vdash \cond(f,g):N,\vec{C}\to N$. 
%  Define $\Gamma'_{l\conc(1)} = \Gamma'_{l\conc(2)} = \Gamma'_l$, and 
%  $\phi'(l) = (S_1,S_2, \Gamma'_l\vdash \cond(f,g):N,\vec{C}\to N)$,
%  where $S_1$ is $\Gamma'_l\vdash f:\vec{C}\to N$ and $S_2$ is $\Gamma'_l \vdash g:N,\vec{C}\to N$, 
%  as an instance of $\cond$. They satisfy (a) and (b). 
%  To show (c), take an index $k$ for $\Gamma_l\vdash \cond(f,g): N,\vec{C}\to N$ as required. 
%  We need to consider three cases:
%  $k$ is the index for a named argument $y \in \FV(\cond(f,g))$ in $\Gamma_l$,
%  is the one for an unnamed argument in $\vec{C}$, or
%  is the one for an unnamed argument in $N$ (the first one of $N,\vec{C}\to N$). 
%  For the first and second cases, we can take $\tilde{k}$, $k'$, and $\tilde{k'}$
%  similar to the other cases.
%  For the last case, the successor $\tilde{k}$ of $k$ should be taken
%  as the index of the unnamed $N$-argument of $\Gamma'_l \vdash g:N,\vec{C}\to N$
%  at the same position as $k$. 
%  Then $k'$ and $\tilde{k'}$ are taken as those equivalent to $k$ and $\tilde{k}$, respectively.
%  Note that this $k$ is an index of a progressing argument $N$, and so is $k'$. 
%\end{proof}
%
%
%
%\begin{lemma}[Substitution lemma]
%  Assume that $\Pi_u: \Delta \vdash u:A$ and $\Pi_t:\Gamma,x:A \vdash t:B$ hold. 
%  Then there exists $\Pi^\circ$ such that $\Pi^\circ:\mergeCtx{\Delta}{\Gamma} \vdash t[u/x]:B$. 
%  Moreover, if both $\Pi_u$ and $\Pi_t$ satisfy the global trace condition,
%  then $\Pi^\circ$ also satisfies it. 
%\end{lemma}
%\begin{proof}
%  Assume that $\Pi_u: \Delta \vdash u:A$ and $\Pi_t:\Gamma,x:A \vdash t:B$ hold. 
%  By Lemma~\ref{lem:thinning}, without loss of generality,
%  we can assume $\FV(\Delta) = \FV(u)$ and $\Pi_t$ is a proof with the restricted $\lambda$ rule (the $\lambda'$ rule). 
%  Let $\Pi_u=(T_u,\phi_u)$ and $\Pi_t=(T_t,\phi_t)$.
%  For each $l\in T_t$, we write $\Gamma_l\vdash t_l:C_l$
%  for the conclusion of $\phi_t(l)$.
%  We use $\xx$ to mark occurences of $x$ in $\Pi_t$ that connects
%  with the explicit $\xx$ of $\Gamma,\xx:A\vdash t:B$. 
%  In the following, we construct a proof $\Pi^\circ = (T^\circ,\phi^\circ)$ of
%  $\mergeCtx{\Delta}{\Gamma}\vdash t[u/x]:B$ such that 
%  \begin{itemize}
%  \item[(a1)]
%    $T^\circ = T_t \cup T_{\var} \cup T_{\apvar}$, where
%    $T_{\var} = \{l\conc(1)\conc l' \mid \text{$l\in T_t$, $\phi(l)=\var$ of $\xx$, and $l'\in T_u$} \}$
%    and
%    $T_{\apvar} = \{l\conc(2)\conc l' \mid \text{$u$ is not a variable, $l\in T_t$, $\phi(l)=\apvar$ of $f(\xx)$ for some $f$, and $l'\in T_u$}\}$.
%    The explicit $1$ of $l\conc(1)\conc l' \in T_\var$ is called the switching point of $l\conc(1)\conc l'$.
%    The explicit $2$ of $l\conc(2)\conc l' \in T_\apvar$ is also called the switching point of $l\conc(2)\conc l'$.     \item[(a2)]
%    For each $l\conc(i)\conc l' \in T_\var \cup T_\apvar$ with switching point $i$,
%    we have $\phi^\circ(l\conc(i)\conc l') = \phi_u(l')$. 
%  \end{itemize}
%  Moreover, for all $l \in T_t$,
%  the rule instance $\phi^\circ(l)$ satisfies the following requirements
%  with an auxiliary function $\sigma^\circ:T_t \to \Seq$ and a substitution $\theta_l$: 
%  \begin{itemize}
%  \item[(b1)]
%    The sequent $\sigma^\circ(l)$ has the form $\Gamma^\circ_l\vdash t_l[\theta_l]:C_l$.
%    The substitution $\theta_l$ is $\{u/\xx\}\cup\theta_{{\rm ren}}$
%    if $\xx:A \in \Gamma_l$, and is $\theta_{{\rm ren}}$ otherwise, 
%    where $\theta_{{\rm ren}}$ is some renaming.
%    $\Gamma^\circ_l \sim \Delta_l\sharp\Restrict{(\Gamma_l)}{\overline{\xx}}[\theta_l]$ holds,
%    where $\Delta_l$ is $\Delta$ if $\xx:A\in\Gamma_l$, and is $\emptyset$ otherwise. 
%  \item[(b2)]
%    $\sigma^\circ(l)$ is the conclusion of $\phi^\circ(l)$,
%    and $\sigma^\circ(l\conc(i))$ is the $i$-th assumption of $\phi^\circ(l)$ if $l\conc(i) \in T_t$.
%  \item[(b3)]
%    Assume $\tilde{k},t_{l\conc(i)}$ is a successor of $k,t_l$ and $k$ is not a named index for $\xx$. 
%    Then there exist $\tilde{k^\circ}$ and $k^\circ$ such that
%    $\tilde{k^\circ},t_{l\conc(i)}[\theta_{l\conc(i)}]$ is a successor of $k^\circ,t_l[\theta_l]$ and 
%    $(k,t_l) \simIndex{\Restrict{(\theta_l)}{\overline{\xx}}} (k^\circ,t_l[\theta_l])$.
%    If $k$ is an index of a progressing argument, then so is $k^\circ$.    
%  \end{itemize}
%  
%  Note that if we have $\Pi^\circ$ that satisfies the requirements, its possibly infinite path
%  is a path of $\Pi_t$ or a path of $\Pi_u$ or a path $l\conc(i)\conc l'$,
%  where $l$ is a path of $T_t$, $i$ is a switching point, and $l'$ is a path of $T_u$.
%  Hence $\Pi^\circ$ is left-finite, since $\Pi_t$ and $\Pi_u$ are left-finite.
%  In addition, if $\Pi_t$ and $\Pi_u$ satisfies the global trace condition,
%  so is $\Pi^\circ$ by (b3). 
%  Therefore, to complete the proof, it is enough to construct $\Pi^\circ$. 
%
%  First, for each $l\conc(j)\conc l'\in T_\var\cup T_\apvar$ with a switching point $j$, 
%  we define $\phi^\circ(l\conc(j)\conc l') = \phi_u(l')$. 
%
%  In the following, for each $l\in T_t$, we inductively define $\Gamma^\circ_l$, $\phi^\circ(l)$, and $\sigma(l)$
%  that satisty (b1), (b2), and (b3).
%  The case of $l=\nil$, define $\Gamma^\circ_\nil = \Delta\sharp\Gamma$ and $\theta_\nil=\{u/\xx\}$,
%  and define $\sigma^\circ(\nil)$ as $\mergeCtx{\Delta}{\Gamma}\vdash t[u/\xx]:A$. 
%  Hence we have (b1) since
%  $\Gamma^\circ_\nil = \mergeCtx{\Delta}{\Gamma} \sim \mergeCtx{\Delta}{\Restrict{(\Gamma,\xx:A)}{\overline{\xx}}[\theta_\nil]}$. 
%
%  For each $l\in T_t$,
%  with the induction hypothesis that $\sigma^\circ(l)$ 
%  and $\theta_l$ that satisfy (b1) are already defined, 
%  we define $\phi^\circ(l)$, and define $\theta_{l\conc(i)}$ 
%  and $\sigma^\circ(l\conc(i))$ when $l\conc(i)\in T_t$, 
%  such that they satisfy (b1), (b2), and (b3). 
%  We perform this by the case analysis of $\phi(l)$.
%
%  The case $\phi(l)= (\Gamma_l\vdash \xx:A)$ that is an instance of $\var$.
%  We can define $\phi^\circ(l) = (\Delta\vdash u:A, \Gamma^\circ_l\vdash u:A)$ as $\weak$,
%  since $\Delta\subseteqsim \mergeCtx{\Delta}{\Restrict{(\Gamma_l)}{\overline{\xx}}[\theta_l]} \sim \Gamma^\circ_l$
%  holds by (b1). 
%  As $l\conc(i)\not\in T_t$, (b1), (b2), and (b3) trivially hold.
%  
%  The case $\phi(l) = (\Gamma_l\vdash y:B)$ that is an instance of $\var$ with $y \neq \xx$. 
%  We can define $\phi^\circ(l) = (\Gamma^\circ_l\vdash \theta_l(y):B)$ as $\var$,
%  since $\theta_l(y):B \in \Restrict{(\Gamma_l)}{\overline{\xx}}[\theta_l] \subseteqsim \mergeCtx{\Delta_l}{\Restrict{(\Gamma_l)}{\overline{\xx}}[\theta_l]} \sim \Gamma^\circ_l$ holds by (b1).
%  As $l\conc(i)\not\in T_t$, (b1), (b2), and (b3) trivially hold.
%
%  The case $\phi(l) = (S_1,S_2,\Gamma_l\vdash f(b):C)$ that is an instance of $\apnotvar$,
%  where $S_1 = \Gamma_l\vdash f:B\to C$, $S_2 = \Gamma_l\vdash b:B$, and $b$ is not a variable. 
%  Define $\phi^\circ(l) = (S'_1, S'_2,\Gamma^\circ_l\vdash f[\theta_l](b[\theta_l]):C)$ as $\apnotvar$, 
%  where $S'_1 = \Gamma^\circ_l\vdash f[\theta_l]:B\to C$ and $S'_2 = \Gamma^\circ_l\vdash b[\theta_l]:B$,
%  since $b[\theta_l]$ is not a variable.
%  Also define $\sigma^\circ(l\conc(1)) = S'_1$, $\sigma^\circ(l\conc(2)) = S'_2$,
%  and $\theta_{l\conc(1)} = \theta_{l\conc(2)} = \theta_l$. 
%  Then (b1) and (b2) trivially hold.
%  To check (b3),
%  assume that $\tilde{k},t$ is a successor of $k,f(b)$, where $t$ is $f$ or $b$,
%  and $k$ is not a named index for $\xx$.
%  Then (i) both $k$ and $\tilde{k}$ are named indexes for some variable $y^D\in\Dom(\Gamma_l)$,
%  (ii) both $k$ and $\tilde{k}$ are unnamed indexes in $C$. 
%  For the case (ii), take $k'$ and $\tilde{k'}$ as the same indexes as $k$ and $\tilde{k}$, respectively.
%  For the case (i), we have
%  $\theta_l(y):D \in \Restrict{(\Gamma_l)}{\overline{\xx}}[\theta_l] \subseteqsim \Gamma^\circ_l \subseteqsim \Gamma^\circ_{l\conc(1)}$ 
%  by $y \neq \xx$. Then take $k'$ and $\tilde{k'}$ as named indexes for $\theta_l(y)$.
%  In each case, $k'$ and $\tilde{k'}$ satisfy (b3) as expected. 
%  
%  The case $\phi(l) = (S_1,\Gamma_l\vdash f(\xx):C)$ that is an instance of $\apvar$, 
%  where $S_1 = \Gamma_l \vdash f:A\to C$ and $\xx:A\in\Gamma_l$. 
%  We need to consider the two subcases whether $u$ is a variable or not.
%  \begin{itemize}
%  \item
%    If $u$ is a variable $y^B$, 
%    we can define $\phi^\circ(l) = (S'_1, \Gamma^\circ_l\vdash f[\theta_l](y):C)$,
%    where $S'_1 = \Gamma^\circ_l\vdash f[\theta_l]:A\to C$ as $\apvar$,
%    since
%    $y:B \in \Delta \subseteqsim \mergeCtx{\Delta}{\Restrict{(\Gamma_l)}{\overline{\xx}}[\theta_l]} \sim \Gamma^\circ_l$
%    holds by (b1). 
%    Also define $\sigma^\circ(l\conc(1)) = S'_1$ and $\theta_{l\conc(1)} = \theta_l$. 
%    Then (b1) and (b2) trivially hold. (b3) is checked in a similar way to the case $\apnotvar$.
%  \item
%    If $u$ is not a variable, 
%    define $\phi^\circ(l) = (S'_1, S'_2, \Gamma^\circ_l\vdash f[\theta_l](u):C)$,
%    where
%    $S'_1 = \Gamma^\circ_l\vdash f[\theta_l]:A\to C$ and
%    $S'_2 = \Gamma^\circ_l\vdash u:A$ as $\apnotvar$. 
%    Also define $\sigma^\circ(l\conc(1)) = S'_1$, $\sigma^\circ(l\conc(2)) = S'_2$,
%    and $\theta_{l\conc(1)} = \theta_{l\conc(2)} = \theta_l$. 
%    Then (b1) and (b2) trivially hold. (b3) is checked in a similar way to the case of $\apnotvar$. 
%  \end{itemize}
%
%  The case $\phi(l) = (S_1,\Gamma_l\vdash f(y):C)$
%  that is an instance of $\apvar$, where $S_1 = \Gamma_l \vdash f:B \to C$, $y:B\in\Gamma_l$ and $y\neq \xx$. 
%  We can define $\phi^\circ(l) = (S'_1, \Gamma^\circ_l\vdash f[\theta_l](\theta_l(y)):C)$ as $\apvar$,
%  where $S'_1 = \Gamma^\circ_l\vdash f[\theta_l]:B\to C$, 
%  since
%  $\theta_l(y):B \in \Restrict{(\Gamma_l)}{\overline{\xx}}[\theta_l] \subseteqsim \mergeCtx{\Delta_l}{\Restrict{(\Gamma_l)}{\overline{\xx}}[\theta_l]} \sim \Gamma^\circ_l$
%  holds by (b1). 
%  Also define $\sigma^\circ(l\conc(1)) = S'_1$ and $\theta_{l\conc(1)} = \theta_l$. 
%  Then (b1) and (b2) trivially hold. (b3) is checked in a similar way to the case $\apnotvar$.
%  
%  The case $\phi(l) = (\Gamma_l, z:C\vdash b:B,\Gamma_l\vdash \lambda z.b:C\to B)$
%  that is an instance of $\lambda'$. 
%  By the assumption, we have $\theta_l$
%  and $\sigma^\circ(l)=\Gamma^\circ\vdash (\lambda z.b)[\theta_l]:C\to B$ that satisfy (b1).
%  Let $\theta_l=\{\vec{u}/\vec{x}\}$. 
%  We consider two subcases.
%  \begin{itemize}
%  \item
%    The first subcase is when $z\not\in\FV(\vec{u})$.
%    We have $(\lambda z.b)[\theta_l] = \lambda z.(b[\Restrict{(\theta_l)}{\overline{z}}])$.
%    Then define $\phi^\circ(l) = (\Gamma^\circ_l, z:C\vdash b[\Restrict{(\theta_l)}{\overline{z}}]:B,\Gamma^\circ_l\vdash \lambda z.(b[\Restrict{(\theta_l)}{\overline{z}}]):C\to B)$ as $\lambda$. 
%    Note that $\Gamma^\circ_l,z:C$ is a context 
%    because $z:C \not\in \mergeCtx{\Delta_l}{\Restrict{(\Gamma_l)}{\overline{\xx}}[\theta_l]} \sim \Gamma^\circ_l$
%    holds by (b1), $z\not\in \FV(\Gamma_l)$ and $z \not\in\FV(\vec{u}) \supseteq \FV(\Delta_l)$
%    (recall that $\Delta_l$ is $\Delta$ when $\xx:A\in\Gamma_l$, and is $\emptyset$ otherwise).
%    Define $\sigma^\circ(l\conc(1)) = \Gamma^\circ_l,z:C\vdash b[\Restrict{(\theta_l)}{\overline{z}}]:B$
%    and $\theta_{l\conc(1)} = \Restrict{(\theta_l)}{\overline{z}}$.
%    We have (b2) by the definition. 
%    We also have (b1) by $(\Gamma^\circ_l,z:C) \sim (\mergeCtx{\Delta_l}{\Restrict{(\Gamma_l)}{\overline{\xx}}}[\theta_l],z:C) = \mergeCtx{\Delta_l}{\Restrict{(\Gamma_l,z:C)}{\overline{\xx}}}[\theta_{l\conc(1)}]$.
%    To check (b3),
%    assume that $\tilde{k},b$ is a successor of $k,\lambda z.b$ and $k$ is not a named index for $\xx$.
%    Then (i) both $k$ and $\tilde{k}$ are named indexes for some variable $y^D\in\Dom(\Gamma_l)$,
%    (ii) both $k$ and $\tilde{k}$ are unnamed indexes (not for $C$), or
%    (iii) $k$ is an unnamed indexes for $C$ and $\tilde{k}$ is a named index for $z$.
%    The cases (i) and (ii) can be checked in a similar way to the case of $\apnotvar$.
%    The case (iii) is checked by taking $k'$ and $\tilde{k'}$ as the same indexes as $k$ and $\tilde{k}$,
%    respectively.
%  \item
%    The second subcase is when $z\in\FV(\vec{u})$.
%    We have $(\lambda z.b)[\theta_l] = \lambda z'.(b[\Restrict{(\theta_l)}{\overline{z}},z'/z])$, 
%    where $z' \not\in\FV(b,\vec{u})$. 
%    Then define $\phi^\circ(l) = (\Gamma^\circ_l, z':C\vdash b[\Restrict{(\theta_l)}{\overline{z}},z'/z]:B,\Gamma^\circ_l\vdash \lambda z'.(b[\Restrict{(\theta_l)}{\overline{z}},z'/z]):C\to B)$ as $\lambda$. 
%    We need to check that $\Gamma^\circ_l,z':C$ is a context.
%    It is shown by
%    $z':C \not\in \mergeCtx{\Delta_l}{\Restrict{(\Gamma_l)}{\overline{\xx}}[\theta_l]} \sim \Gamma^\circ_l$
%    using (b1), 
%    $z'\not\in \FV(\lambda z.b) = \FV(\Gamma_l)$ and $z' \not\in\FV(\vec{u}) \supseteq \FV(\Delta_l)$. 
%    Define $\sigma^\circ(l\conc(1)) = \Gamma^\circ_l,z':C\vdash b[\Restrict{(\theta_l)}{\overline{z}},z'/z]:B$
%    and $\theta_{l\conc(1)} = \Restrict{(\theta_l)}{\overline{z}}\cup\{z'/z\}$.
%    We have (b2) by the definition. 
%    We also have (b1) by $(\Gamma^\circ_l,z':C) \sim (\mergeCtx{\Delta_l}{\Restrict{(\Gamma_l)}{\overline{\xx}}}[\theta_l],z':C) = \mergeCtx{\Delta_l}{\Restrict{(\Gamma_l,z:C)}{\overline{\xx}}}[\theta_{l\conc(1)}]$.
%    Checking (b3) is done in a similar way to that of the first subcase.
%  \end{itemize}
%
%  The case $\phi(l) = (S_1,S_2,\Gamma_l\vdash \cond(f,g):\N\to C)$, where
%  $S_1 = \Gamma_l\vdash f:C$, $S_2 = \Gamma_l\vdash g:\N\to C$, as an instance of $\cond$. 
%  Define $\phi^\circ(l) = (S'_1,S'_2,\Gamma^\circ_l\vdash \cond(f[\theta_l],g[\theta_l]):\N\to C)$ as $\cond$,
%  where $S'_1 = \Gamma^\circ_l \vdash f[\theta_l]:C$ and $S'_2 = \Gamma^\circ_l \vdash g[\theta_l]:\N\to C$.
%  Also define $\sigma^\circ(l\conc(1)) = S'_1$, $\sigma^\circ(l\conc(2))  = S'_2$,
%  and $\theta_{l\conc(1)} = \theta_{l\conc(2)} = \theta_l$. 
%  Then (b1) and (b2) trivially hold.
%  (b3) is checked in a similar way to the case of $\apnotvar$.
%
%  The case $\phi(l) = (\Gamma_l\vdash 0:\N)$, as an instance of $0$. 
%  Define $\phi^\circ(l) = (\Gamma^\circ_l\vdash 0:\N)$ as $0$. 
%  Since $l\conc(i)\not\in T_t$, (b1), (b2), and (b3) trivially hold.
%  
%  The case $\phi(l) = (\Gamma_l\vdash t:\N, \Gamma_l\vdash \Succ(t):\N)$, as an instance of $\Succ$. 
%  Define
%  $\phi^\circ(l) = (\Gamma^\circ_l\vdash t[\theta_l]:\N, \Gamma^\circ_l\vdash \Succ(t[\theta_l]):\N)$ as $\Succ$. 
%  Also define $\sigma^\circ(l\conc(1)) = \Gamma^\circ_l\vdash t:\N$
%  and $\theta_{l\conc(1)} = \theta_l$.
%  Then (b1) and (b2) trivially hold.
%  (b3) is checked in a similar way to the case of $\apnotvar$.
%
%  Therefore our construction of $\Pi^\circ$ is completed.
%\end{proof}
%
%We now prove an Inversion property for global trace condition: if a proof satisfies the global trace condition, 
%then all its immediate subproofs do.
%
%%\begin{lemma}(Inversion Lemma)\label{lem:inversion}
%%  \begin{enumerate}
%%  \item\label{lem:inversion1}
%%    If $\Pi:\Gamma\vdash f(a):A$ and $\Pi$ satisfies the global trace condition, then
%%    there exist $\Pi_1$, $\Pi_2$ and $B$ such that
%%    $\Pi_1:\Gamma\vdash f:B\to A$, $\Pi_2:\Gamma\vdash a:B$,
%%    and both $\Pi_1$ and $\Pi_2$ satisfy the global trace condition. 
%%  \item\label{lem:inversion2}
%%    If $\Pi:\Gamma\vdash \lambda x^T.b:A$, where $x\not\in\FV(\Gamma)$,
%%    and $\Pi$ satisfies the global trace condition, then
%%    there exist $\Pi_1$ and $B$ such that
%%    $\Pi_1:\Gamma,x:T\vdash b:B$ and $A = T\to B$,
%%    and $\Pi_1$ satisfies the global trace condition. 
%%  \item\label{lem:inversion3}
%%    If $\Pi:\Gamma\vdash \cond(f,g):A$ and $\Pi$ satisfies the global trace condition, then
%%    there exist $\Pi_1$, $\Pi_2$ and $B$ such that
%%    $\Pi_1:\Gamma \vdash f:B$, $\Pi_2:\Gamma \vdash g:N\to B$, $A = N\to B$,
%%    and both $\Pi_1$ and $\Pi_2$ satisfy the global trace condition. 
%%  \item\label{lem:inversion4}
%%    If $\Pi:\Gamma\vdash \Succ(t):A$ and $\Succ(t) \in \GTC$, then    
%%    there exists $\Pi_1$ such that $\Pi_1:\Gamma \vdash t:N$, $A=N$, 
%%    and $\Pi_1$ satisfies the global trace condition. 
%%  \end{enumerate}
%%\end{lemma}
%
%\begin{proof}(Inversion Lemma \ref{lem:inversion})
%  We first claim that if $t\in\GTC$ and $\Pi:\Gamma\vdash t:A$ with $\Pi=(T,\phi)$, 
%  then there exists $l\in T$ such that $\phi(l) \neq \weak$ and $\phi(m) = \weak$ for all $m < l$.
%  Because, if not, the only infinite path in $\Pi$ is the consective use of $\weak$,
%  which does not contain progressing trace, this contradicts with $t\in\GTC$.
%
%  We show the point \ref{lem:inversion1}.
%  Assume that $\Pi:\Gamma\vdash f(a):A$ with $\Pi=(T,\phi)$ and $f(a) \in \GTC$.
%  By the claim, take $l\in T$ such that $\phi(l) \neq \weak$ and $\phi(m) = \weak$ for all $m < l$.
%  Let $\Gamma' \vdash f(a):A$ be the conclusion of $\phi(l)$. Then $\Gamma'\subseteqsim \Gamma$ holds
%  by the transitivity of $\subseteqsim$.
%  Now $\phi(l)$ is $\apvar$ or $\apnotvar$.
%  In the former case $\phi(l) = \apvar$, we have $\Pi\restr l\conc(1):\Gamma'\vdash f:B\to A$ for some $B$,
%  and $a = x^B \in \Gamma'$. Hence we have a proof $\Pi_1:\Gamma\vdash f:B\to A$ by $\weak$. 
%  We also obtain $\Pi_2:\Gamma\vdash a:B$ by $a = x^B \in \Gamma'$ and $\weak$. 
%  In the latter case $\phi(l) = \apnotvar$,
%  we have $\Pi\restr l\conc(1):\Gamma'\vdash f:B\to A$ and $\Pi\restr l\conc(2):\Gamma'\vdash a:B$ for some $B$. 
%  Hence we have a proof $\Pi_1:\Gamma\vdash f:B\to A$ and $\Pi_2:\Gamma\vdash a:B$ by $\weak$.
%  In both cases, if $t\in\GTC$, we have $f\in\GTC$ and $a\in\GTC$ by the construction of $\Pi_1$ and $\Pi_2$. 
%  
%  The points \ref{lem:inversion2}, \ref{lem:inversion3}, and \ref{lem:inversion4} are shown similarly. 
%\end{proof}
%
%%
%%\begin{theorem}[Subject reduction]
%%\label{theorem-subject-reduction}
%%  Assume that $\Pi_t:\Gamma\vdash t:A$, $\Pi_t$ satisfies the global trace condition, and $t\reduces u$.
%%  Then there exists $\Pi_u$ such that $\Pi_u:\Gamma\vdash u:A$ and $\Pi_u$ satisfies the global trace condition. 
%%\end{theorem}
%
%\begin{proof}(Subject reduction, Theorem \ref{theorem-subject-reduction})
%  By the definition of $t\reduces u$, there is a context $\hat{t}[-]$ such that
%  $t=\hat{t}[t_0]$, $u=\hat{t}[u_0]$, and $t_0\reduces_\Box u_0$, where $\Box\in\{\beta,\cond\}$. 
%  Since $t_0$ is a subterm of $t$, there is $l$ such that $\Pi_t\restr l: \Gamma_0\vdash t_0:A_0$.
%  Note that $\Pi_t\restr l$ satisfies the global trace condition,
%  since it is a subtree of $\Pi_t$, which satisfies the global trace condition. 
%  Then, if we have $\Pi'_u:\Gamma_0\vdash u_0:A_0$ that satisfies the global trace condition,
%  the tree obtained from $\Pi_t$ by replacing the subtree $\Pi_t\restr l$ by $\Pi'_u$ is also
%  a proof of $\Gamma\vdash \hat{t}[u_0]:A$ that satisfies the global trace condition. 
%  Hence it is enough to show the following:
%  \begin{itemize}
%  \item[(a)]
%    If $\Pi:\Gamma \vdash (\lambda x^A.b)(a): B$ and it satisfies the global trace condition,
%    then $\Pi':\Gamma \vdash b[a/x]: B$ for some $\Pi'$ that satisfies the global trace condition.
%  \item[(b)]
%    If $\Pi:\Gamma \vdash \cond(f,g)(0): B$ and it satisfies the global trace condition,
%    then $\Pi':\Gamma \vdash f: B$ for some $\Pi'$ that satisfies the global trace condition. 
%  \item[(c)]
%    If $\Pi:\Gamma \vdash \cond(f,g)(\Succ(t)): B$ and it satisfies the global trace condition,
%    then $\Pi':\Gamma \vdash g(t): B$ for some $\Pi'$ that satisfies the global trace condition. 
%  \end{itemize}
%  (b) is shown immediately by Lemma~\ref{lem:inversion}~\ref{lem:inversion3}.
%  We show (c).
%  Assume $\Pi:\Gamma \vdash \cond(f,g)(\Succ(t)): B$.
%  Then by \ref{lem:inversion1}, \ref{lem:inversion3}, and \ref{lem:inversion4} of Lemma~\ref{lem:inversion},
%  we have
%  $\Pi_1:\Gamma \vdash g:N\to B$ and $\Pi_2:\Gamma \vdash t:N$,
%  where $\Pi_1$ and $\Pi_2$ satisfy the global trace condition. 
%  Hence, by applying $\apnotvar$ or $\apvar$ to $\Pi_1$ and $\Pi_2$, 
%  we have a proof $\Pi':\Gamma\vdash g(t):B$ that satisfies the global trace condition. 
%  In order to show (a), assume $\Pi:\Gamma \vdash (\lambda x^A.b)(a): B$.
%  Then by Lemma~\ref{lem:inversion}~\ref{lem:inversion1},
%  we have $\Pi_1:\Gamma \vdash \lambda x^A.b:A\to B$ and $\Pi_2:\Gamma \vdash a:A$,
%  where $\Pi_1$ and $\Pi_2$ satisty the global trace condition. 
%  Then, by Lemma~\ref{lem:thinning},
%  we have $\Pi'_1:\Restrict{\Gamma}{\FV(\lambda x.b)} \vdash \lambda x^A.b:A\to B$,
%  where $\Pi'$ satisfies the global trace condition. 
%  By Lemma~\ref{lem:inversion}~\ref{lem:inversion2},
%  we have a proof $\Pi''_1:\Restrict{\Gamma}{\FV(\lambda x.b)},x:A \vdash b:B$
%  that satisfies the global trace condition. 
%  Hence, by the substitution lemma, we have a proof $\Pi':\Gamma\vdash b[a/x]:B$
%  that satisfies the global trace condition, as we wished. 
%\end{proof}
%
%Using the subject reduction theorem, variable renaming is shown to be admissible in our system. 
%
%%\begin{proposition}(Renaming)
%%\label{prop:renaming}
%%  \begin{enumerate}
%%  \item\label{prop:renaming1}
%%    Let $\theta$ be a renaming.
%%    If $\Pi:\Gamma\vdash t:A$ and $\Gamma[\theta]$ is a context, 
%%    then $\Pi':\Gamma[\theta]\vdash t[\theta]:A$ for some $\Pi'$.
%%    Moreover, if $\Pi$ satisfies the global trace condition, so is $\Pi'$.
%%  \item\label{prop:renaming2}
%%    If $\Pi:\Gamma\vdash t:A$ and $t'$ is an $\alpha$-equivalent term of $t$,
%%    then $\Pi':\Gamma\vdash t':A$ for some $\Pi'$.
%%    Moreover, if $\Pi$ satisfies the global trace condition, so is $\Pi'$.
%%  \end{enumerate}
%%\end{proposition}
%
%
%\begin{proof}(Renaming, Proposition \ref{prop:renaming})
%  We show the point \ref{prop:renaming1}. 
%  It is enough to show the claim for a single renaming $\theta = \{y'/y\}$.
%  Then, by the assumption, we have a proof $\Pi_1$ of $\Gamma[y'/y] \vdash (\lambda y^B.t)y':A$
%  such that $\Pi_1$ satisfies the global trace condition if $\Pi$ satisfies it.  
%  Hence we have $\Pi': \Gamma[y'/y] \vdash t[y'/y]:A$ by the subject reduction theorem
%  such that $\Pi'$ satisfies the global trace condition if $\Pi$ satisfies it.
%
%  Next we show the point \ref{prop:renaming2}.
%  It is enough to show when $t = \lambda x.b$ and $t' = \lambda x'.(b[x'/x])$, where $x'\not\in\FV(\lambda x.b)$. 
%  Let $\Pi$ be a proof of $\Gamma\vdash \lambda x.b:A\to B$.
%  Then we have $\Pi_1: \Restrict{\Gamma}{\FV(\lambda x.b)} \vdash \lambda x.b:A\to B$
%  by Lemma~\ref{lem:thinning}, and
%  also have $\Pi_2: \Restrict{\Gamma}{\FV(\lambda x.b)},x':B \vdash b[x'/x]:B$
%  by the subject reduction theorem. 
%  Hence we have $\Pi': \Gamma \vdash \lambda x'.b[x'/x]:A\to B$ by the rules $\lambda$ and $\weak$. 
%  Note that $\Pi'$ satisfies the global trace condition if $\Pi$ satisfies it. 
%\end{proof}
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%
% SECTION 6
% finite safe reductions
%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\begin{lemma}[The $\prec$-order]
%\label{lemma-prec-order}
%Assume $t \in \WTyped$ has type $\N$, and $t$ is finite for safe reductions .
%
%\begin{enumerate}
%\item
%\label{lemma-prec-order-01}
%There is no infinite sequence 
%$\sigma: t = t_0 \reduces^{*} \Succ(t_1) \reduces^{*} \Succ^2(t_2) \reduces^{*} \ldots$
%
%\item
%\label{lemma-prec-order-02}
%$\prec$ is well-founded on total terms of type $\N$.
%\end{enumerate}
%\end{lemma}

%%%%%%%%%%%%%%%%%%%
% checked 10:30 03/04/2025
%%%%%%%%%%%%%%%%%%%

\begin{proof}(The $\prec$-order, Lemma \ref{lemma-prec-order})
Assume that $t \in \WTyped$ has type $\N$, and $t$ is finite for safe reductions.
\begin{enumerate}
\item 
%\label{lemma-prec-order-01}
Assume that there is some infinite sequence 
$\sigma: t = t_0 \reduces^{*} \Succ(t_1) \reduces^{*} \Succ^2(t_2) \reduces^{*} \ldots$ 
to show a contradiction. Since $t$ is finite for safe-reductions, 
$\sigma$ only has finitely many safe-reductions. 
Thus, from some $k\in\N$ there are no more safe reductions from
$\Succ^k(t_k)$. This implies that for some $\cond$-free term 
$u$ and some terms $f_1, g_1, \ldots, f_m, g_m$ we have
$t_k = u[\cond(f_1,g_1), \ldots, \cond(f_m,g_m)]$ and all reductions from $t_k$ on are inside
some $g_1, \ldots, g_m$. This means for all $h \in \N$, $h \ge k$ we  have
$\Succ^{h}(t_{h}) =  u[\cond(f_1,g'_1), \ldots, \cond(f_n,g'_m)]$ for some 
$g'_1, \ldots, g'_m$. This implies that first $h$ symbols of $u$ are $\Succ$.
This is a contradiction when $h$ is larger than 
%%%%%%%%%%%%%%%%%%%%%
% 12:40 14/02/2025 REMOVED: ``$k$, which is''
%%%%%%%%%%%%%%%%%%%%%
the number of symbols in $u$.

\item
%\label{lemma-prec-order-02}
Assume for contradiction that there is some infinite sequence
$\ldots t_n \prec \ldots \prec t_2 \prec t_1 \prec t_0 = t$
from some $t_0:\N$ total. By assumption, $t_0$ is finite for safe reductions.
Then there is some infinite sequence 
$\sigma: t = t_0 \reduces^{*} \Succ(t_1) \reduces^{*} \Succ^2(t_2) \reduces^{*} \ldots$,
contradicting point \ref{lemma-prec-order-01} above.
\end{enumerate}
\end{proof}




%\begin{proposition}[Trace assignment]
%\label{prop:trace_assign-finiteness}
%Assume $\Pi:\Gamma \vdash t:A$ and there is some infinite path $\pi$ of $\Pi$ 
%for which we have
%some \emph{total} trace-compatible assignment  $\rho$ to $\pi$. 
%\begin{enumerate}
%\item
%\label{prop:trace_assign-finiteness1}
%Any trace $\sigma$ in $\pi$ progresses only finitely many times.
%\item
%\label{prop:trace_assign-finiteness2}
%$t \not \in \GTC$.
%\end{enumerate}
%\end{proposition}



\begin{proof}(Trace assignment, Prop.
\ref{prop:trace_assign-finiteness})
%%%%%%%%%%%%%%%%%%%
% checked 11:04 03/04/2025
%%%%%%%%%%%%%%%%%%%
Assume $\Pi:\Gamma \vdash t:A$ and there is some infinite path $\pi$ of $\Pi$ for which we 
have some \emph{total} trace-compatible assignment  $\rho(\cdot,\cdot)$ to $\pi$.
\begin{enumerate}
\item
%\label{prop:trace_assign-finiteness1}
Assume $\sigma$ is any trace of $\pi$ in order to prove
that $\sigma$ progresses only finitely many times.
Suppose at step $i \in \N$ the trace $\sigma$ moves from the argument number 
$\sigma(i)$ to the argument number $\sigma(i+1)$.
By definition of trace-compatible assignment $\rho$, if $\sigma$ progresses at step $i$
then $\rho(i+1,\sigma(i+1))\prec \rho(i,\sigma(i))$, and if $\sigma$ 
does not progress at step $i$,  then  $\rho(i+1,\sigma(i+1)) = \rho(i,\sigma(i))$
The assignment $\rho$ is made of total terms of type $\N$.
By definition of total for type $\N$, each $\rho(i,\sigma(i))$ is finite for safe reductions. 
$\prec$ is well-founded on such terms
by lemma \ref{lemma-prec-order}.\ref{lemma-prec-order-02}.
Thus, we have $\rho(i+1,\sigma(i+1))\prec \rho(i,\sigma(i))$ only finitely many times, 
therefore $\sigma$ progresses only finitely many times, as we wished to show.

\item
%\label{prop:trace_assign-finiteness2}
By point \ref{prop:trace_assign-finiteness1} above, no trace $\sigma$ 
from any argument in any term of the branch $\pi$ of $\Tree(t)$ progresses infinitely many 
times. We assumed that $\pi$ is an infinite path in $\Pi$.
By definition of $\GTC$, we conclude that $t \not \in \GTC$. 
\end{enumerate}
\end{proof}


%\begin{lemma}(Total terms and Finiteness for Safe Reductions, \label{lem:total_value-finiteness})
%Assume $t,u,f,a \in \WTyped$, $n \in \N$ and $A,B,T$ are types.
%
%  \begin{enumerate}
%  \item
%\label{lem:total_value-finiteness1}
%    Let $t:A$ and $t \reduces^{*} u$.
%    If $t$ is total, then $u$ is total.
%
%  \item
%\label{lem:total_value-finiteness2}
%    If $f:A \rightarrow B$ and $a:A$ are total terms, then $f(a)$ is total.
%
%  \item
%\label{lem:total_value-finiteness2bis}
%    $x^T:T$ is total.
%
% \item
%\label{lem:total_value-finiteness2ter}
%  If $t$ is total then $t$ is  finite for safe reductions.
%
%  \item
%\label{lem:total_value-finiteness3}
%    Let $U$ be any atomic type, and $t[\vec{x}]:\vec{A}\rightarrow U$ be a term
%    whose all free variables are $\vec{x}:\vec{B}$.
%
%    If for all total $\vec{u}:\vec{B}$, $\vec{a}:\vec{A}$ the term 
%    $t[\vec{u}]\vec{a}: U$ is \emph{finite for safe reductions}, then
%    the term $t[\vec{x}]$ is \emph{total by substitution}.
%  \end{enumerate}
%
%\end{lemma}

\begin{proof}(Total terms and Finiteness for Safe Reductions, 
Lemma \ref{lem:total_value-finiteness})
\begin{enumerate}
%%%%%%%%%%%%%%%%%%%%%
% checked 11:49 03/04/2025
%%%%%%%%%%%%%%%%%%%%%
\item
%\label{lem:total_value-finiteness1}
  We show \emph{point \ref{lem:total_value-finiteness1}}  by induction on the type $A$ of $t$. 
  We assume that $t:A$ and $t \reduces ^*u$.
  and $t$ is total, in order to prove that $u$ is total.
  By the subject reduction property, $u$ has type $A$.
\begin{enumerate}
\item
  We show the \emph{base case}, namely when $A =\N,\alpha$ is an atomic type.
  By the assumption, $t$ is total.
  By definition of $t$ total for $T$ atomic, all infinite 
  reductions from $t$ only include finitely many safe reductions, for all $n \in \N$.
  In particular, all infinite reductions $\sigma: t \reduces \ldots \reduces 
  u \reduces u_1 \reduces u_2 \ldots$ 
  passing through $u$ only include finitely many safe reductions. We conclude that
  all infinite reductions 
  $\sigma': u \reduces u_1 \reduces u_2 \ldots$  from $u$
  only include finitely many safe reductions. 
  From $u:A =\N,\alpha$ we conclude that  $u$ is total.
  
\item
  We show the \emph{induction case}, namely when $A = (A_1\rightarrow A_2)$.
  Take any arbitrary total term $a:A_1$ in order to prove that $u(a):A_2$ is total. 
  Then we have $t(a) \reduces^{*} u(a)$ and 
  $t(a):A_2$ is total by the assumption that $t$ is total.
  Hence $u(a)$ is total by $t(a) \reduces^{*} u(a)$ and the induction hypothesis on $A_2$,
  for all total terms $a:A_1$. 
  We conclude that $u:A_1\rightarrow A_2$ is total. 
\end{enumerate}

  \item
%\label{lem:total_value-finiteness2}
If $f:A \rightarrow B$, $a:A$ are total  terms, then $f(a)$  is total by definition of total.

\item
%\label{lem:total_value-finiteness3}
We prove that $x^T:T$ is total and that 
if $t:T$ is total then $t$ is finite for safe reductions.
We argue by principal induction on $T$.

\begin{enumerate}
\item
In order to prove that $x^T:T$ is total we prove a little more, namely
that for all types $\vec{A} = A_1, \ldots, A_n$, 
all total $\vec{a}:\vec{A}$, if $T = \vec{A} \rightarrow U$ then $x(\vec{a}):U$
is total. The thesis will follows by taking $\vec{a} = \nil$. 
We argue by secondary induction on $U$. 

\begin{enumerate}
\item
Assume $U$ is atomic. Every reduction on $x(\vec{a}):U$
takes place in $\vec{a}$. By definition of total
for an atomic type we have to prove that in all infinite reduction sequences from $x(\vec{a}):U$ 
there are only finitely many safe reduction. 
Since each $a_i$ in $\vec{a}$ is total, by principal induction hypothesis on $A_i$ 
only finitely many safe reductions are possible from $a_i$. 
All reductions on $x(\vec{a})$ take place on $\vec{a}$, therefore
only finitely many safe reductions are possible. 
\item
Assume $U = A_1 \to A_2$. By definition of total
for an arrow type we have to prove that for all total $a$ we have  $x(\vec{a},a):A_2$ total.
This follows by secondary induction hypothesis on $A_2$.
\end{enumerate}

\item
%\label{lem:total_value-finiteness4}
\emph{We assume that  $t:T$ is total in order to prove that $t$ is finite for safe reductions},
for all $n \in \N$.
\begin{enumerate}
\item
If $T$ is atomic then the thesis is true by definition of total.
\item
Suppose $T = (A_1 \rightarrow A_2)$. By principal induction hypothesis on $A_1$,
the variable 
$x^{A_1}:A_1$ is total, therefore $t(x):A_2$ is total and by induction hypothesis on $A_2$
any infinite reduction sequence from $t(x)$ only includes finitely many safe reductions. 
Any infinite reduction sequence 
$\sigma: t = t_0 \reduces_1 t_1 \reduces_1 t_2 \reduces_1 \ldots$  from $t$ 
can be raised to an infinite reduction sequence 
$\tau: t(x) = t_0(x) \reduces_1 t_1(x) \reduces_1 t_2(x) \reduces_1 \ldots$ from $t(x)$
while preserving the fact that a reduction is safe, because $t$ occurs in no $\cond$ in $t(x)$.
We conclude that $\sigma$ only includes finitely many safe reductions. 
\end{enumerate}
\end{enumerate}

\item  
%\label{lem:total_value-finiteness5}
Assume $U=\N, \alpha$ is any atomic type, and $t[\vec{x}]:\vec{A}\rightarrow U$ is a term
whose all free variables are $\vec{x}:\vec{B}$.
Assume that for all total $\vec{u}:\vec{B}$, $\vec{a}:\vec{A}$ the term 
$t[\vec{u}]\vec{a}: U$ is \emph{finite for safe reductions}. We have to prove that
$t[\vec{x}]$ is \emph{total by substitution}.
We assume that  $\vec{u}:\vec{B}$ and we have to prove that $t[\vec{u}]$ is total.
We argue by induction on the number $|\vec{A}|$ of elements of $\vec{A}$.
\begin{enumerate}
\item
  In the \emph{base case} $|\vec{A}| = 0$, the thesis $t[\vec{u}]$ is equal to the assumption.
\item
  We show the \emph{induction case}. Let $\vec{A} = A_0,\vec{A'}$.
  Take arbitrary totals $\vec{u}:\vec{B}$, $\vec{a'}:\vec{A'}$, and $a_0:A_0$. 
  By the assumption, we have that $t[\vec{u}]a_0\vec{a'}: U$ is total  for all 
  vector of total terms $\vec{a'}$. 
  Then $t[\vec{u}]a_0:\vec{A'}\rightarrow U$ is total for all total $a_0:A_0$
  by the induction hypothesis on $\vec{A'}\rightarrow U$.
  By definition of total we deduce that $t[\vec{u}] : A_0,\vec{A'}\rightarrow U$ is total.
\end{enumerate}
We conclude that $t[\vec{x}]$ is total by substitution, as we wished to show.
\end{enumerate}
\end{proof}



%\begin{lemma}[Safety-preserving Simulation]
% \label{lemma-safety-preserving-simulation}
%Define a binary relation $R \subseteq \LAMBDA \times \LAMBDA$ by:
%$t R u$ if and only if there are $v,a,b \in \LAMBDA$ and a variable $x$
%such that:
%\begin{center}
%$(b \reduces^{*} a)$
%  \ \ \  and  \ \ \ 
%$(t = v[a/x])$
%  \ \ \  and  \ \ \ 
%$(u = v[b/x])$
%\end{center}
%
%Then $ R$ 
%is a \emph{safety-preserving} simulation  on $\LAMBDA$
%between $\reduces  $ and $\reduces^{+}$, namely:
%\begin{enumerate}
%\item
%whenever $t,u,t' \in \LAMBDA$, $t R u$ and $t \reduces   t'$ 
%then for some $u' \in \LAMBDA$ we have $t' R u'$ and $u \reduces^{+} u'$.
%\item
%Besides, if $t \reduces   t'$ is safe then some step in
%$u \reduces^{+} u'$ is safe, too.
%\end{enumerate}
%\end{lemma}

\begin{proof}(Safety-preserving Simulation, 
Lemma \ref{lemma-safety-preserving-simulation})
%%%%%%%%%%%%%%%%%%%%%%%
% checked 09:00 04/04/2025
%%%%%%%%%%%%%%%%%%%%%%%
Let $R$ as in Lemma \ref{lemma-safety-preserving-simulation}.
Assume that $t \in \LAMBDA$, $u \in \LAMBDA$, $t' \in \LAMBDA$
and $t R u$ and $t \reduces   t'$. 
We have to prove that for some $u' \in \LAMBDA$ 
we have $t' R u'$ and $u \reduces^{+} u'$ and besides that
if $t \reduces   t'$ is safe then some step in
$u \reduces^{+} u'$ is safe, too.
\\

The assumption $t R u$ unfolds to: for some $a, b,w  \in \LAMBDA$,
some variable $y$, 
we have $(b \reduces^{*} a)$ and $(t = w[a/y])$ and $(u = w[b/y])$.
By renaming $y$ in $v$ with some variable $x \not \in \FV(w,a,b)$ 
we have that $(t = w[x/y][a/x])$ and $(u = w[x/y][b/x])$ and
$x \not \in \FV(w,a,b)$. If we set $v=w[x/y]$ we have
$(t = v[a/x])$ and $(u = v[b/x])$ and
$x \not \in \FV(a,b)$.
\\

The assumption $t \reduces t'$ implies that for some unique redex 
$r \sqsubseteq t$, for some context $C[\cdot]$
we have $t = C[r]$ and $t' = C[r']$ and $r \reduces r'$. 
The possible shapes of $r$
are $r = (\lambda x.c)(d), \cond(f,g)(0), \cond(f,g)(\Succ(e))$ 
and the corresponding shapes of $r'$ are  $r' = c[d/x], f, g(e)$.
Thus, for some $r_1, r_2$ we have $r = r_1(r_2)$. 
%We call $r_1 = (\lambda x.c), \cond(c,d), \cond(c,d)$ the body of $r$ and
%$r_2= d,0,\Succ(e)$ the argument of $r$.
Assume $\pi$ is the position of $r$ in $t$. If $r \reduces r'$ is safe, then 
$\pi$ crosses no right-hand side of any $\cond$.
We argue by cases on $\pi$.
Either $\pi$ is some position of $v$ or it is not.


\begin{enumerate}

\item
\emph{Assume that $\pi$ is \emph{not} the position of a node of $v$}. 
Then there is some free occurrence of $x$ in $v$, with position $\theta$, 
such that $\pi \ge \theta$. Assume $D[\cdot]$ is the context with a single hole
$\cdot$ in the position $\theta$ of $z$.
From $x \not \in \FV(a) \cup \FV(b)$ we deduce
that $ t  = D[a][a/x]$ and $u  = D[b][b/x]$.
For some context $C$ we have $a = C[r] \reduces C[r']$.
By definition we have
$ t  = D[a][a/x] = D[C[r]][a/x]$ and 
$ u = D[b][b/x]$ and
$ t' = D[C[r']][a/x]$. 
We choose $u' = D[C[r']][b/x]$.
We deduce $t' R u'$.  
From $r \reduces   r'$ 
we deduce $D[r] \reduces  
D[r']$, then $b \reduces^{*} a = C[r] \reduces  
C[r']$, hence $b \reduces^{+} C[r']$. 
Eventually we deduce
$
u = D[b][b/x] 
\reduces^{*} 
D[C[r]][b/x] 
\reduces
D[C[r']][b/x] 
= u'$.
If the reduction $t = D[C[r]][a/x]  \reduces D[C[r']][a/x] $ is safe,
then the last reduction$D[C[r]][b/x] \reduces D[C[r']][b/x] $ in 
$u \reduces u'$ is safe.

\item
\emph{Assume that $\pi$ the position of some node $s$ in 
$v$ and \emph{$s$ is some redex}}.  
There exists some context $D$ such that $v = D[s]$. Then $r=s[a/x]$
and $r'=s'[a/x]$ for some redex $s=s_1(s_2)$ of $v$.
$s$ is contracted to $s'$ with the same reduction used for $r$.
We deduce that:
$ t  = v[a/x] = D[s][a/x]$ and 
$ u = v[b/x] = D[s][b/x]$ and
$ t' = D[s'][a/x]$. 
We choose $u' = D[s'][b/x]$. 
From $b \reduces^{*} a$ we deduce that
$t' = D[s'][a/x]$ and 
$u' = D[s'][b/x]$ are related by $R$.
Thus, we have $t' R u'$. From  $s \reduces   s'$ we deduce that 
$
u = D[s][b/x]
\reduces   
D[s'][vec{b}/x] = u'
$.
If $r \reduces r'$ is safe, then 
$\pi$ crosses no right-hand side of any $\cond$, therefore the last reduction
$s \reduces s'$ is safe in $u$.


\item
\emph{Assume that $\pi$ the position of some node $s$ in 
$v$,  yet \emph{$s$ is no redex}}.  
There exists some context $D$ such that $v = D[s]$. 
$\pi$ is the position of an application $r_1(r_2)$ in $t$, therefore
$\pi$ is the position of some application $s = s_1(s_2)$ is $v$.
If $s$ is no redex, then either $s_1, r_1$ do not start with the same symbol,
or and $s_2, r_2$ do not start with the same symbol. In the first sub-case
we have $s_1=x$, $r_1 = s_1[a/x] = a$ and $r = r_1(r_2) = a(r_2)$.
In the second sub-case
we have $s_2=x$, $r_2 = s_2[a/x] = a$ and $r = r_1(r_2) = r_1(a)$.
We cannot have both case at the same time, 
because the type of $r_2$ is the type of an argument of $r_1$. 
Therefore $r_1$, $r_2$ have two different types and $a$ cannot have both types.
Thus, if $s_1=x$ then $r_2,s_2$ start with the same symbol, and if
$s_2=x$ then $r_1,s_1$ start with the same symbol.

\begin{enumerate}
\item
\emph{Sub-case: $s_1=x$ and $r_2,s_2$ start with the same symbol}. 
We have $r1(r_2) = a(s_2[a/x]) = $ (by $x \not \in \FV(a)$) $ a(s_2)[a/x]$ 
If we re-define $s_1=a$ we have that $s_1$ has the same starting symbol
as $r_1$ and $s_2$ has the same starting symbol as $r_2$.
Thus, $s = s_1(s_2)$ is a redex, it reduces to some $s'$ with the same reduction
we have in $r \reduces r'$, and by unicity of contractum we have $r' = s'[a/x]$.
For the context $D$ such that $v=D[s]$
we have: 
$ t  = v[a/x] = D[s][a/x] = D[a(s_2)][a/x]$ and 
$ u = D[b(s_2)][b/x] $ and
$ t' = D[s'][a/x]$. 
We choose $u' = D[s'][b/x]$ 
and we deduce $t' R u'$. 
From $b(s_2) \reduces^{*} a(s_2) = s \reduces   s'$
we deduce that $u = D[b(s_2)][b/x] \reduces^{*} 
D[s][b/x] \reduces D[s'][b/x] = u'$.

\item
\emph{Sub-case: $s_2=x$ and $r_1,s_1$ start with the same symbol}. 
We have $r = r_1(r_2) = r_1(a)$ and
$r_1 = s_1[a/x]$ for some $s_1$ with the same starting symbol as $r_1$.
We re-define $s_2=a$. Then $s_2=a$ has the same starting symbol as $r_2=a$,
therefore $ s = s_1(s_2) = s_1(a)$ reduces to some $s'$, 
and by unicity of contractum we have $r' = s'[a/x]$.
For some context $D$ we have: 
$ t  = D[s_1(a)][a/x]$ and 
$ u = D[s_1(b)][b/x]$ and
$ t' = D[s'][a/x]$. 
We choose $u' = D[s'][b/x]$ 
and we deduce $t' R u'$. 
From $s_1(b) \reduces^{*} s_1(a) = s \reduces   s'$
we deduce that $u = D[s_1(b)][b/x] \reduces^{*} D[s_1(a)][b/x] 
= D[s_1(s_2)][b/x] 
\reduces D[s'][b/x] = u'$.
\end{enumerate}

In all cases, if $t \reduces   t'$ is safe then the reduction $s[a/x] \reduces   s'[a/x]$ 
is safe in $D[s][a/x] \reduces  D[s'][a/x] = t'$
and therefore the reduction $s[b/x] \reduces   s'[b/x]$
is the last reduction step in  $u \reduces   D[s'][b/x] = u'$ and it is
safe, too.
\end{enumerate}
\end{proof}


%
%%\begin{lemma}[Safe infinite reductions and Substitution]
%% \label{lemma-safe-infinite-substitution}
%%Let $a \in \LAMBDA$, 
%%$b \in \LAMBDA$ 
%%and $v \in \LAMBDA$. 
%%If $b \reduces^{+} a$ and there is some reduction with 
%%\emph{with infinitely many safe steps} from $v[a/x]$, 
%%then there is some reduction with
%%\emph{with infinitely many safe steps} from $v[b/x]$.
%%\end{lemma}
%
%\begin{proof}(Safe infinite reductions and Substitution, 
%Lemma \ref{lemma-safe-infinite-substitution})
%%%%%%%%%%%%%%%%%%%%%%%%%
%% checked 09:17 04/04/2025
%%%%%%%%%%%%%%%%%%%%%%%%%
%We prove that if $a \reduces^{*} a'$ then we can move one reduction from
% $v[a']$ to to one or more from  $v[a]$, while preserving safe reductions. 
% 
% We assume that  $a \reduces^{*} a'$ and $v[a'] \reduces w$ in order to prove that:
%  for some $z$ we have $w=z[a']$ and $v[a] \reduces^+ z[a]$, and
%if $v[a'] \reduces w$ is a safe then the last reduction in $v[a] \reduces^+ z[a]$ is safe.
%The proof is by cases on the reduction $v[a'] \reduces w$.  
%
%\begin{enumerate}
%
%\item
%Assume the reduction $v[a'] \reduces w$ is on a redex of the form $r[a']$, with both the left
%and right hand-side of $r$ not included in any $a'$ obtained by substitution. 
%In this case we have $v[a'] = e[r[a'],a'] \reduces e[s'[a'],a']$, and
%$r[a'] = \cond(f[a'],g[a'])(0) \reduces f[a'] = s[a']$ or 
%$r[a'] = \cond(f[a'],g[a'])(S(t[a'])) \reduces g[a'](t[a']) = s[a']$
%or $r[a'] = (\lambda x.t[a',x])(u[a']) \reduces t[a',u[a']] = s[a']$. 
%We define $z[a'] = e[s'[a'],a']$. 
%In all three sub-cases we have $r[a] \reduces s[a]$ and therefore $v[a] \reduces e[r[a],a] = z[a]$
%if $v[a'] \reduces z[a']$ is safe then $v[a] \reduces z[a]$ is safe.
%
%\item
%%  {\Large\color{red} This proof should be fixed}
%Assume the reduction $v[a'] \reduces w$ is on a redex of the form $r$, with either the left
%or right hand-side of $r$ not included in some $a'$. In this case either $r$ is included in some $a'$ 
%obtained by substitution, or the left or right hand side of $r$ is equal to some $a'$ obtained by substitution.
%We cannot have both the left and right hand side equal to $a$, because the two sides of any redex 
%have a different type.
%
%In this case there is a single $a'$ whose value matters, that is, $v[a] = v_0[a][a]$, with the first $a$ denoting
%the single occurrence of $a$ we are speaking about. We choose $v'[.] = v_0[a'][.]$, then we have
%$v'[a']=v_0[a'][a']=v[a']$ by definition, and $v[a] = v_0[a][a] \reduces^{*} v_0[a'][a] = v'[a]$ 
%because $a \reduces^{*} a'$ and there is a single occurrence of $a$ in $v_0[a][.]$. 
%
%The reduction on $v'[a']$ has both the left
%and right hand-side of $r$ not included in any $a'$ obtained by substitution, because this unique
%$a'$ is not part of $v'[.]$. We conclude from the previous case applied to $v'[a]$, $v'[a']$.
%
%\end{enumerate}
%Then by induction on $n' \in \N$ we prove that if $v[a'] \reduces^{n'} w$ ($n'$ steps) 
%then for some $z$, some $n \ge n'$ we have $w=z[a']$ and $v[a] \reduces^{n} z[a]$,
%with the number of safe reductions in  $v[a'] \reduces^{n'} z[a']$ less or equal than the number
%of safe reductions in $v[a] \reduces^{n} z[a]$.
%
%\end{proof}

%
%\begin{theorem}[Main Theorem]
%\label{theorem-main-finite-safe-reduction}
%  Assume $\Pi:\Gamma\vdash t : A$ (hence $t\in \WTyped$).
%  If $t$ is \emph{not} total by substitution, then $t \not \in \GTC$, i.e.:
%  there is some infinite path $\pi = (e_1, e_2, \ldots)$ of $\Pi$ with no infinite progressing trace. 
%\end{theorem}

\begin{proof}(Main Theorem \ref{theorem-main-finite-safe-reduction})
%%%%%%%%%%%%%%%%%%%%%
% checked 11:38 04/04/2025
%%%%%%%%%%%%%%%%%%%%%
  We assume that $\Pi:\Gamma \vdash t: A$ 
  and $t$ is not total by substitution in order to prove that
  $t \not \in \GTC$. As a corollary, all terms of $\CTlambda$ will be total by substitution.
 
  Let $\Gamma = \vec{x}:\vec{D} = x_1^{D_1}:D_1, \ldots, x_n^{D_n}:D_n$ 
  and $A = \vec{A}\rightarrow U = A_1, \ldots, A_m \rightarrow U$, 
  for some \emph{atomic} type $U$. $U$ is $\N$ or some type variable $\alpha$.
   
  By Proposition \ref{prop:trace_assign-finiteness}.\ref{prop:trace_assign-finiteness2} 
  it is enough to prove that
  $\Pi$ has some infinite branch $\pi=(e_1, e_2, \ldots)$ 
  and some \emph{total} trace-compatible assignment $\rho$ for $\pi$.
  Now we will define such $\pi$.
  
  By case \ref{lem:total_value-finiteness3} of Lemma~\ref{lem:total_value-finiteness},
  if $t[\vec{x}]$ is \emph{not} total by substitution, then 
  there exist total terms $\vec{a}:\vec{A}$ and $\vec{d}:\vec{D}$ for which there is
  an infinite reduction $\sigma$ from $t[\vec{d}]\vec{a}$ having infinitely many safe  
  reductions.
  By induction on $i \in \Nat$, for each $i$, we construct a path 
  $l_i = (e_1,\ldots,e_{i-1}) \in \universe{\Pi}$
  and a total assignment $\rho(l_i) = \vec{v_i} = (\vec{d_i},\vec{a_i})$ such that
  $(\vec{v_1},\ldots,\vec{v_i})$ is a total trace-compatible assignment for the node $l_i$
  and $t_{i}[\vec{d_{i}}](\vec{a_{i}})$ is not total.

%  We have to find some $(l_i,\vec{d_i},\vec{a_i})$ such that:
%  \begin{itemize}
%  \item[(i)]
%%15:38 19/04/2024
%   $l_i = (e_1, \ldots, e_{i-1}) \in \universe{\Pi}$ 
%     %and $\Label(\Pi,l_i) = \vec{x_{i}}:\vec{D_{i}}\vdash t_{i} : \vec{A_{i}}\rightarrow\N$; 
%%  \item[(ii)]
%%    $t_{i}$ is not total by substitution;
%  \item[(ii)]
%    $\vec{d_{i}}:\vec{D_i}$ and $\vec{a_i}:\vec{A_i}$ are total terms
%    such that $t_{i}[\vec{d_i}]\vec{a_i}$ is not total;
%  \item[(iii)]
%    the total assignment 
%    $\vec{d_1},\vec{a_1}$, \ldots, $\vec{d_i},\vec{a_i}$) is trace-compatible for $l_i$.
%    %\Daisuke{mynote:write this more clearly}
%  \end{itemize}
  
 We recall that \quotationMarks{trace compatible in $i$} means: 
 if $i-1$ is a progress point, namely if $t_{i-1}=\cond(f,g)$ and $e_i=2$ 
 (we move to the right subterm) and $t_i=g$, then $\vec{a_{i-1}} = a',\vec{a'}$ 
 and $a'$, the first unnamed argument of $\cond(f,g) : \N \rightarrow A$, 
 reduces to $\Succ(a'')$w hile $\vec{a_i} = a'',\vec{a'}$.
 In all other cases two corresponding arguments of $\rho(i-1)$ and $\rho(i)$ are equal.

  We first define $(l_1,\vec{d_1},\vec{a_1})$ for the root node $t$ of $\Pi$.
  In this case $l_1 = \nil$ 
   and $(\vec{d},\vec{a})$ are total terms such that $t[\vec{d}](\vec{a})$ is not total
   (has some infinite reduction with infinitely many safe reduction).
  Trace compatibility is vacuous because the branch $l_1$ only contains one node.
  %Points (i), (ii), (iii), (iv) are immediate.

  Next, assume that $(l_i,\vec{d_i},\vec{a_i})$ is already constructed.
  Then we define $(l_{i+1},\vec{d_{i+1}},\vec{a_{i+1}})$ by the case analysis on
  the last rule for the node $l_i$ in $\Pi$. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APPARENTLY THE CASE $\struct(f)$ CAN BE SIMPLIFIED TO WEAKENING-Stefano
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{enumerate}

\item
%WEAK
  The case of $\weak$ happens when
  $\Label(\Pi,l_{i+1}) = \Gamma \vdash t_{i+1}:\vec{A_i}\rightarrow U$
  is the premise of a $\weak$-rule, with conclusion
  $\Delta \vdash t_{i}:\vec{A_i}\rightarrow U$. We have:

\begin{enumerate}
\item
 $t_i = t_{i+1}$. 
\item
  $\Gamma = x_1:D_1,\ldots,x_n:D_n$, $\Delta= x'_1:D'_1,\ldots,x'_{n'}:D'_{n'}$, and 
  $\Gamma \subseteqsim \Delta$,
  with an injection $\phi:\{1,\ldots,n\}\to\{1,\ldots,n'\}$ from $\Gamma$ to $\Delta$
\item
  $\phi$ maps variables of the premise into variables of the conclusion:
   $x'_{\phi(j)} = x_j$ and $D'_{\phi(j)} = D_j$ for all $j \in \{1,\ldots,n\}$.
\end{enumerate}

  By the induction hypothesis, 
  $t_i[d_{i,1}/x'_1,\ldots,d_{i,{n'}}/x'_{n'}]\vec{a_i}$ is not total,
  for some total assignment $\vec{d_i} = d_{i,1}\ldots d_{i,{n'}}$, $\vec{a_i}$.
  All variables of $\Delta$ which occur free in $t_i$ are of the form 
  $x_{\phi(j)} \in \FV(\Gamma)$, we deduce that
  $
   t_i[d_{i,1}/x'_1,\ldots,d_{i,{n'}}/x'_{n'}]\vec{a_i}
  $
  simplifies to
  $
   t_i[d_{i,\phi(1)}/x_1,\ldots,d_{i,\phi(n)}/x_n]\vec{a_i} 
  $.
  In this case 
  we define $l_{i+1} = l_i\conc(1)$ taking the unique child node of $l_i$ in $\Pi$, and we
  also define $\vec{d_{i+1}}$ and $\vec{a_{i+1}}$ by $d_{i,\phi(1)}\ldots d_{i,\phi(n)}$
  and $\vec{a_i}$, respectively. This is an assignment with total terms such that
  $t_{i+1}[\vec{d_{i+1}}](\vec{a_{i+1}})$ is not total.
  $((\vec{d_i},\vec{a_i}),(\vec{d_{i+1}},\vec{a_{i+1}}))$
  is trace compatible for $(t_i,t_{i+1})$: if two arguments are connected 
  by $\phi$ then they are assigned to the same term. 

\item
%VAR
  The case of $\var$-rule, namely $\Label(\Pi,l_i) = \Gamma\vdash x:D$ 
  for some $x_{i,k}:D_{i,k} = x:D \in \Gamma$
  cannot be, because $t_i [\vec{d_i}/\vec{x_i}] = d_{i,k}$ is total  by assumption on $\vec{d}$.
  
\item
%0-RULE
  The case of $0$-rule, namely $\Label(\Pi,l_i) = \Gamma\vdash 0:\N$, 
  cannot be. Indeed, $t_i = 0$ is total because $0$ is a numeral.

%12:58 06/06/2024


\item 
%SUCC 
  The case of $\Succ$-rule, 
  namely $\Label(\Pi,l_i) = \Gamma\vdash t_i: \N = \Gamma\vdash \Succ(u): \N$
  for some $u$ is obtained from our assumptions on
  $\Gamma\vdash u: \N$. In this case $\vec{a_i}$ is empty, $t_{i+1}=u$, and
  by the induction hypothesis $\Succ(u)[\vec{d_i}]:\N$ has an infinite reduction with
  infinitely many safe reductions
  $\Succ(u) \reduces  \Succ(u_1) \reduces \Succ(u_2) \reduces \ldots$,
  all taking place on $u$.
  Then, by the definition of total, $u[\vec{d_i}] =t_{i+1}[\vec{d_i}] $ is not total, because the
 $u \reduces_1  u_1 \reduces_1 u_2 \reduces_1 \ldots$ is an infinite reduction with
  infinitely many safe reductions.

  We define $e_{i}=1$, 
  the index of the unique child node of $l_{i+1}=l_i\conc(1)$ in the $\Succ$-rule, and
  we also define $\vec{d_{i+1}} = \vec{d_i}$ and $\vec{a_{i+1}} = ()$. 
  This is an assignment with total terms and 
  trace compatible for $(t_i,t_{i+1})$: if two arguments are connected then they are assigned
  to the same term. 

%13:05 06/06/2024


\item
  The case of the $\apnotvar$-rule, namely 
  $\Label(\Pi,l_i) = \Gamma\vdash t_i: \vec{A}\rightarrow U$, 
  with $t_i = f[\vec{x}](u[\vec{x}])$ for some $f$ and $u$, 
  where $u$ is \underline{not} a variable.
  The premises of the $\apnotvar$-rule
   are $\Gamma\vdash f[\vec{x}]: B \rightarrow \vec{A}\rightarrow U$ 
  and $\Gamma\vdash u[\vec{x}]: B$.
  By the induction hypothesis, there is some infinite reduction from
  $t_i[\vec{d_i}]\vec{a_i} = f[\vec{d_i}](u[\vec{d_i}])\vec{a_i}:U$ 
  with infinitely many safe-reductions.
  We argue by cases on the statement: \emph{$u[\vec{d_i}]:B$ is total}.


%11:04 05/06/2024


\begin{enumerate}
\item
  We first consider the subcase: \emph{$u[\vec{d_i}]:B$ is total}.
  We define $b = u[\vec{d_i}]$, a total term, 
  then $l_{i+1}=l_i \conc (1)$, taking the first premise of the rule,
  and we define $\vec{d_{i+1}} = \vec{d_i}$ and $\vec{a_{i+1}} = b,\vec{a_i}$. 
  This is an assignment with total values, 
  and providing an infinite reduction with infinitely many safe reductions, as expected. 
  The connection from 
  $(\vec{d_i},\vec{a_i})$ to $(\vec{d_{i+1}},\vec{a_{i+1}}) = (\vec{d_i},b,\vec{a_i})$ 
  is trace-compatible: all connected 
  $\N$-argument of $t_{i}=f(u)[\vec{x}]$ and $t_{i+1}[\vec{x}] = f[\vec{x}]$ are the same,
  because the only fresh argument of $f[\vec{x}]$ 
  is $b$ and no argument of $f(u)[\vec{x}]$ is connected to it.
\item
  Next we consider the subcase that \emph{$u[\vec{d_i}]:B$ is not total}.
  Let $B = \vec{C}\rightarrow U$.
  By lemma \ref{lem:total_value-finiteness}.\ref{lem:total_value-finiteness3}
  there is a sequence of values $\vec{c}:\vec{C}$ and an infinite reductions from 
  $u[\vec{d_i}]\vec{c}: U$ with infinitely many safe reductions.
  Define $l_{i+1}= l_i \conc (2)$ taking the second premise of the rule,
  and define $\vec{d_{i+1}} = \vec{d_i}$ and $\vec{a_{i+1}} = \vec{c}$. 
  This is an assignment with total terms providing an infinite reductions with 
  infinitely many safe reductions, as expected.
  The connection from 
  $(\vec{d_i},\vec{a_i})$ to $(\vec{d_{i+1}},\vec{a_{i+1}}) = (\vec{d_i},\vec{c})$ is
  trace compatible: all connected $\N$-argument of $t_{i} = f(u)[\vec{x}]$ and $t_{i+1}=u[\vec{x}]$ are 
  in $\vec{d_i}$ and therefore are the same, and no unnamed arguments in $\vec{a_i}$
  and $\vec{a_{i+1}}$ are connected each other.
 \end{enumerate}

\item
  The case of $\apvar$-rule, namely 
  $\Label(\Pi,l_i) 
  = 
  \Gamma \vdash f[\vec{x}](x): \vec{A}\rightarrow U$ is obtained from
  $\Gamma \vdash f[\vec{x}]: D,\vec{A} \rightarrow U$,
  where $\Gamma=x_1:D_1,\ldots,x_n:D_n$ and $x:D\in\Gamma$, therefore
  $x:D = x_k:D_k$ for some $k \in [1,n]$. 
  By the induction hypothesis, 
  there is an infinite reduction from $f[\vec{d_i}]d_{i,k}\vec{a_i}: U$
  with infinitely many safe reductions,
  where $\vec{d_i} = (d_{i,1},\ldots,d_{i,n})$. 
  Define $l_{i+1}=l_i\conc(1)$ as the unique child of $l_i$ in $\Pi$, and
  also define $\vec{d_{i+1}} = \vec{d_i}$ and $\vec{a_{i+1}} = d_{i,k},\vec{a_i}$. 
  This is an assignment with total terms providing an infinite reductions with 
  infinitely many safe reductions, as expected.
  The connection from
  $(\vec{d_i},\vec{a_i})$ to
  $(\vec{d_{i+1}},\vec{a_{i+1}}) = (\vec{d_i},d_{i,k},\vec{a_i})$
  is trace compatible: all connected $\N$-arguments in $\vec{d_i},\vec{a_i}$ and 
  $\vec{d_{i+1}},\vec{a_{i+1}}$ are the same.  
  The only difference between the two assignments
  is that, if $D_k = \N$, the value $d_{i,k}$ of type $\N$ for the variable $x_k$
  in $t_i[\vec{x}]=f[x_1,\ldots,x_k,\ldots,x_n](x_k)$ is duplicated to the term $d_{i,k}$ 
  assigned to the first unnamed argument of $ f[\vec{x}]$. 

%08:40 05/09/2024
%11:01 04/04/2025

\item
  The case of $\lambda$-rule, namely when a sequent
  $
    \Label(\Pi,l_i) 
    = 
    \Gamma\vdash t_i : A, \vec{A} \rightarrow U
  $ 
  with 
  $
    t_i 
    = 
    \lambda x^A.u[\vec{x},x]
  $
  is obtained from
  $
  \Gamma\setminus\{x:A\},x:A
  \vdash 
  t_{i+1}[\vec{x},x^A]:\vec{A}\rightarrow U
  $, 
  where $t_{i+1}[\vec{x},x]=u[\vec{x},x]$.
  
  By the induction hypothesis we have an infinite reduction sequence $\sigma$ from
  $t_i[\vec{d_i}]\vec{a_i} = (\lambda x.(u[\vec{d_i},x]))\vec{a_i}: U$ 
  with infinitely many safe reductions, where $\vec{a_i} = a,\vec{b}$. 
  Define $\vec{d'_i}$ by skipping from $\vec{d_i}$ all positions $j$ such that $x_j = x$.
  Define $l_{i+1}=l_i\conc(1)$ as the unique child of $l_i$ in $\Pi$,
  and $\vec{d_{i+1}} = \vec{d'_i},a$, and $\vec{a_{i+1}} = \vec{b}$. 
  This is an assignment with total terms. The connection from 
  $(\vec{d_i},\vec{a_i})$ to $(\vec{d_{i+1}},\vec{a_{i+1}}) = (\vec{d'_i},a, \ \vec{b})$ is
  trace compatible: all connected $\N$-argument of 
  $t_{i}=\lambda x^A.u[\vec{x},x]$ and $t_{i+1}=u[\vec{x},x]$ are 
  the same, except for the first unnamend argument $a$ of $\vec{a_i}$ which is moved to
  the last named argument of $u[\vec{x},x]$, the argument with name $x$.
 
  We have to prove that there is some infinite reduction from 
  $t_{i+1}[\vec{d_{i+1}}](\vec{a_{i+1}})$ with infinitely
  many safe reductions. This requires some care because, as we pointed out,
  reduction and substitution do not commute for infinite $\lambda$-terms.
  We argue by case.

\begin{enumerate}
\item
 Suppose all reductions in the infinite reduction $\sigma$ 
  are inside $\lambda x.(u[\vec{d_i},x])$ or $\vec{a_i}$.
 By Lemma \ref{lem:total_value-finiteness}.\ref{lem:total_value-finiteness2bis},
  there are finitely many safe reductions in $\vec{a_i}$ because $\vec{a_i}$ is total.
 Thus, there are infinitely many safe reductions on the part of $\sigma$
  taking place on $\lambda x.(u[\vec{d_i},x])$.
  We conclude that there is an infinite reduction from $u[\vec{d_i},x]$ 
  with infinitely many safe reduction. This is true for $u[\vec{d_i},a]$, too, 
  because reductions and safe reductions are closed by substitution of $x$ with $a$.
  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 09:39 05/09/2024
% non è vero che a-->a' implica v[a] ---> v[a'] 
% ma è vero che se da v[a'] ci sono infinite safe-reductions
% allora da v[a] ci sono infinite safe-reductions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\item
 Suppose there is some reduction in $\sigma$ contracting the first $\beta$-redex.
 Then  $(\lambda x.(u[\vec{d_i},x]))a\vec{b}$ reduces first to some
 $ (\lambda x.v[x])a'\vec{b'}$, then to $v[a']\vec{b'}$, with: 
 $u[\vec{d_i},x] \reduces^{*} v[x]$ and 
 $a\reduces^{*} a'$ and $\vec{b} \reduces^{*} \vec{b'}$.
 Then the reduction sequence $\sigma$ continues with some infinite reduction $\sigma'$ from 
  $v[a']\vec{b'}$, including infinitely many safe reductions. 
 From $u[\vec{d_i},x] \reduces^{*} v[x]$ and $\vec{b} \reduces^{*} \vec{b'}$ we deduce that 
 \[
 t_{i+1}[\vec{d_i},a]\vec{b}  
 \quad =\quad
 u[\vec{d_i},a]\vec{b} 
 \quad\reduces^{*}\quad
 v[a]\vec{b}
 \quad\reduces^{*}\quad
 v[a]\vec{b'} 
 \ \ \ \mbox{(1)}
 \]
 We proved that there is a reduction $\sigma'$ 
 including infinitely many safe reductions from  $v[a']\vec{b'}$.
 From $a \reduces^{*} a'$ and Lemma \ref{lemma-safety-preserving-simulation}
 we deduce that there is a reduction including infinitely many safe reductions from  
 $v[a]\vec{b'}$. From $(1)$ above we conclude that the same holds for
 $t_{i+1}[\vec{d_i},a]\vec{b}$.
\end{enumerate}

%13:55 06/06/2024
%11:31 04/04/2025

\item
  The case of $\cond$-rule, namely a sequent
  $\Label(\Pi,l_i) = \Gamma\vdash t_i:\N,\vec{A}\rightarrow U$
  having $t_i[\vec{x}] = \cond(f[\vec{x}],g[\vec{x}])$,
  and obtained from 
  $\Gamma\vdash f[\vec{x}]:\vec{A}\rightarrow U$
  and
  $\Gamma\vdash g[\vec{x}]:\N,\vec{A}\rightarrow U$. 
  By the induction hypothesis, there is some infinite reduction sequence $\sigma$ from
  $t_i[\vec{d_i}]a \vec{b} = \cond(f[\vec{d_i}],g[\vec{d_i}])a\vec{b}: U$
  with infinitely many safe reductions,
  where $\vec{a_i} = a,\vec{b}$. 
  We argue by case.

\begin{enumerate}
\item
  \emph{Suppose the reduction sequence $\sigma$ never contracts the leftmost $\cond$.}
  $a$ and $\vec{b}$ are total, 
  by Lemma \ref{lem:total_value-finiteness}.\ref{lem:total_value-finiteness2bis}
  only finitely many reduction on them are possible.
  Then infinitely many safe reductions take place on $f[\vec{d_i}]$ or $g[\vec{d_i}]$. 
  All these safe reduction are in $f[\vec{d_i}]$, because
  a reduction inside $g[\vec{d_i}]$ is in the right-hand-side of some $\cond$, 
  therefore it is not safe.
  The safe-infinite reduction from $f[\vec{d_i}]$ can be raised to an infinite reduction from 
  $f[\vec{d_i}](\vec{b})$, with the same safe reductions, therefore with infinitely
  many safe reductions.
  In this case we take $f[\vec{x}],\vec{d_i},\vec{b}$ as next step of our path in $\Pi$:
  we choose $l_{i+1} = l_i \conc (1)$, $\vec{d_{i+1}} = \vec{d_i}$, and
  $\vec{a_{i+1}} = \vec{b}$.  This is an assignment with total terms.

  We have trace-compatibility because: 
  each argument of $t_i$ is connected to some equal argument of 
  $t_{i+1}[\vec{x}]=f[\vec{x}]$,
  the first argument of $t_i[\vec{x}]$ disappears 
  but it is connected to no $\N$-argument in $f[\vec{x}]$.

\item
  \emph{Suppose the reduction sequence contracts the leftmost $\cond$-redex at some step.}
  Then $t_i[\vec{d_i}]a \vec{b} \reduces^{*} \cond(f',g')a''\vec{b'}$, 
  with $a'' = 0$ or $a'' = \Succ(a')$. 
  Then in the first subcase $\cond(f',g')a''\vec{b'} \reduces f'\vec{b'}$, in the second subcase
  $\cond(f',g')a''\vec{b'} \reduces g' a' \vec{b'}$, 
  with $f[\vec{d_i}] \reduces^{*} f'$, $g[\vec{d_i}] \reduces^{*} g'$, 
  and $\vec{b} \reduces^{*} \vec{b'}$.
  After this $\cond$-reduction we have a reduction sequence 
  with infinitely many safe reductions.
  We prove our thesis by subcases, according if $a'' = 0$ or $a'' = \Succ(a')$.
   
%19:37 05/09/2024

\begin{enumerate}
\item
  \emph{Suppose $a'' = 0$}.
   In this case we take $f[\vec{x}],\vec{d_i},\vec{b}$ as the next step of our path in $\Pi$:
  we choose $l_{i+1} = l_i \conc (1)$, $\vec{d_{i+1}} = \vec{d_i}$, 
  and $\vec{a_{i+1}} = \vec{b}$. 
  This is an assignment with total terms.
  $f[\vec{d_{i+1}}](\vec{b})$ reduces to $f' \vec{b'}$, 
  then we have infinitely many safe reductions.

  We have trace-compatibility because: 
  each argument of $t_i$ is connected to some equal argument of
  $t_{i+1}[\vec{x}]=f[\vec{x}]$,
  the first argument of $t_i[\vec{x}]$ disappears   
  but it is connected to no $\N$-argument in $f[\vec{x}]$.
%12:53 05/06/2024

 \item
  \emph{Suppose $a'' = \Succ(a')$}. 
  We choose $l_{i+1} = l_i \conc (2)$, $\vec{d_{i+1}} = \vec{d_i}$, and
  $\vec{a_{i+1}} = a',\vec{b}$. This is an assignment with total terms: $a'$ is total because
  all reduction sequences from $a'$ can be raised from a reduction sequences from 
  $a'' = \Succ(a')$ with the same safe-reduction. From $a \reduces^{*} a''$ we deduce that
  there are finitely many safe-reductions from $a''$, therefore finitely many those from $a'$.
 
  We have trace-compatibility because: each argument of $t_i[\vec{x}]$ is connected 
  to some equal argument of $t_{i+1}[\vec{x}]=g[\vec{x}]$,
  but for the first unnamed argument $a$ of $t_i[\vec{x}]$ 
  which is connected the first unnamed argument of $g[\vec{x}]$.
  This is fine because in the second premise of a $\cond$ 
  the trace progresses and, indeed, we have $a' \prec a$, 
  because $a \reduces^{*}  a'' = \Succ(a')$.

  \end{enumerate}
 \end{enumerate}
\end{enumerate}

By the above construction, we have an infinite path $\pi = (e_1,e_2,\ldots)$ in $\universe{\Pi}$
and a trace-compatible assignment, as we wished to show.

\end{proof}



%
%\begin{proposition}[Closed Safe-Normal terms of Type $\N$]
%\label{proposition-closed-safe-normal-term-N}
%\begin{enumerate}
%\item
%All $t \in \GTC$ are sound
%\item
%If $t \in \GTC$, $t$ is closed and $0$-safe-normal and $t:\N$ then $t \in \Num$ ($t$ is a numeral)
%\end{enumerate}
%\end{proposition}


\begin{proof}(Closed Safe-Normal terms of Type $\N$, 
Prop. \ref{proposition-closed-safe-normal-term-N})
%%%%%%%%%%%%%%%%%%%%%
% checked 09:56 03/04/2025
%%%%%%%%%%%%%%%%%%%%%
\begin{enumerate}
\item
We assume that $t \in \GTC$ in order to prove that $t$ is sound.
We argue by  induction on the size of the $0$-safe level of $t$ (the set of $0$-safe subterms
of $t$): this size is finite because $t \in \GTC$. 
We consider one case for each possible first symbol of $t$.

\begin{enumerate}
\item
$t =x$. Then $t$ is open.

\item
$t=0$. Then $t$ is a numeral.

\item
$t = \Succ(u)$. Then $u:\N$ and $u$ has a smaller $0$-safe level, therefore $u$ is sound. 
If $u$ is open then $t$ is open. If $u$ has a $0$-safe \emph{closed} 
redex then so does $t$. $u$ cannot have an arrow type. If $u$
is a numeral then $t$ is a numeral.

\item
$t=u(v)$. Then $u:A \rightarrow B$, $u:A$ for some types $A, B$, 
and $u$, $v$ have a smaller $0$-safe level, therefore $u$, $v$ are both sound. 
We argue by cases on the definition of sound for $u$, $v$.
\begin{enumerate}
\item
If $u$ or $v$ are open then $t$ is open. 
Now assume that $u$ and $v$ are both closed, therefore $t$ is closed.
\item
If $u$ or $v$ have a $0$-safe \emph{closed} redex, then so does $t$.
Now assume that $u$ and $v$ have no $0$-safe \emph{closed} redex.
\item
Suppose $u = \lambda x.v, \cond(f,g)$. 
If $u = \lambda x.v$ then $t=u(v)$ is a $0$-safe $\beta$-redex and $t$ is \emph{closed}.
If $u = \cond(f,g)$ then $A = \N$ and $v:\N$. 
$v$ is not open nor has a a $0$-safe \emph{closed} redex, and $v$ has no arrow type. 
The only possibility left is that $v$ is a numeral: 
we conclude that $t=\cond(f,g)(v)$ is a $\cond$-redex and $t$ is \emph{closed},
therefore $t$ is sound.
\item
The only possibility left is that $u$ is a numeral. 
But this cannot be, because $u$ has an arrow type.
\end{enumerate}

\item
$t = \lambda x.u$. Then $t$ is sound.

\item
$t = \cond(f,g)$. Then $t$ is sound.
\end{enumerate}

\item
Assume that $t \in \GTC$, $t$ is closed and $0$-safe-normal and $t:\N$.
Then $t$ is sound by the previous point and the only possibility left is that $t$ is 
a numeral.
\end{enumerate}
\end{proof}



%16:32 30/04/2024
%22:30 03/06/2024
\subsection{The Ackermann Function (Better Code it is Easier to Analyse)}
The Global Trace Condition is a \quotationMarks{fragile} property: two
terms can be trivial variant each other, can compute the function, yet
one term can satisfy the global trace condition while the other term does not.
As an example we consider Péter and Robinson version of Ackermann function. We can write it in two ways, as:
  \[
  \AckA = \lambda \redm, \bluen.\Cond{\Suc{\bluen}}{\lambda m'.\Cond{\AckA(m',1)}{\lambda n'.\AckA(m',\AckA(\mathbf{\Suc{m'}},n'))}(\bluen)}(\redm)
  \]
and as 
  \[
  \AckB = \lambda \redm, \bluen.
\Cond{\Suc{\bluen}}{\lambda m'.\Cond{\AckB(m',1)}{\lambda n'.\AckB(m',\AckB(\redm,n'))}(\bluen)}(\redm)
  \]
The only difference between the two terms is that $\Suc{m'}$ in the first
term becomes $\redm$ in the second term. $\AckA$ and $\AckB$ are 
extensionally equal, because in all computations $m'$ is the predecessor of $m$. 
However, by direct computation we find out that 
$\AckA$ does \emph{not} satisfy the Global Trace condition, while $\AckB$ does
satisfy it. 

The reason is that the value of the term $u= \Suc{m'}$ is already stored in a 
variable $\redm$, so we should write $\ldots (\mathbf{\Suc{m'}},n') \ldots$ in the 
form  $\ldots (\redm,n') \ldots$, for two reasons.
First, it is a waste of time to recompute the value $u= \Suc{m'}$ if this value is 
already stored in $\redm$. Second, if we write $\ldots (\redm,n') \ldots$ instead of 
$\ldots (\Suc{m'},n') \ldots$, then we use the variable $\redm$ as argument of our
term. When we use a variable as argument, way we add more connections and 
more traces to our term, and it is more likely that the Global Trace algorithm finds 
some infinitely increasing trace and therefore proves that the map we defined is 
total. Replacing  a term $u$ with a variable $\redm$, when this replacing is sound, 
provides better code which is easier to prove total automatically.