% !TEX root = main.tex
\section{The circular simply typed $\lambda$-calculus $\CTlambda$}\label{section-circular-system-CTlambda}

We introduce a condition called \emph{global trace condition} (GTC) for any pre-proof 
$\Pi$ that the term $t$ is well-typed. GTC implies a termination result (see below). 
As we explained in the introduction,
GTC was already defined for infinitary simply typed \emph{combinatorial} terms
(\cite{2021-Anupam-Das}). 
Our contribution is to give an explicit formulation of GTC in the case of the binder $\lambda$.

We will write $\GTC$ for the set of well-typed terms 
$t \in \LAMBDA$ satisfying the global trace condition, for some pre-proof 
$\Pi::\Gamma \vdash t:A$, some context $\Gamma$ and some type $A$. 
We will prove that closed terms of $\GTC$ define a set of total functionals:
they include all functionals of G\"{o}del's system $\systemT$,
and we conjecture they define exactly this set of functionals.

We are particularly interested to the set of terms  $\CTlambda = \GTC \cap \Reg$, namely
regular terms that satisfies the global trace condition.
The reason is that $\CTlambda$ is a decidable subset of $\Reg$
(\cite{SCT}, Theorem 4)  and that its terms can be represented by finite graphs.
We will prove that all reduction strategies
%, church-rosser for the \quotationMarks{safe} part of a term, 
on a closed term of type $\N$ of $\CTlambda$  strongly normalize to a numeral.
As a consequence, all closed terms of $\CTlambda$ are total functionals. 

By building over the notion of trace progressing in an index $i$,
we now define the global trace condition and the set of terms $\GTC$ and $\CTlambda$.
Informally, the global trace condition requires that all infinite branches have some trace 
of some argument $\N$ passing infinitely many times through the right-hand side of a $\cond$.

\begin{definition}[$\GTC$ and $\CTlambda$]\label{definition-global-trace-condition}
Assume $\Pi$ is a pre-proof.
%% $\pi$ 
%% is a possibly infinite path of $\Pi$ and $\tau =( (k_m,\theta_m), \ldots, (k_n,\theta_n), \ldots)$ 
%% is a possibly infinite trace of a path $\pi = (\theta_1, \ldots, \theta_n, \ldots)$. 
%% Assume $i$ is an index of $\pi$.
\begin{enumerate}
%\item
%$\tau$ is progressing in the index $i$ if and only if: $\theta_i$ is labeled by some $\cond$-rule
%and by some judgment $\Gamma \vdash \cond(f,g):\N \rightarrow A$),
%$\theta_{i+1}$ is the right child of $\theta_i$
%labeled by the judgment $\Gamma \vdash g:\N \rightarrow A$,
%and $k_i$ is the index of the first \emph{unnamed} argument of $\theta_i$.
%Otherwise $\tau$ is not progressing in $i$.
\item
A trace $\tau$ of a path $\pi$ in $\Pi$ is \emph{infinitely progressing} 
if there are infinitely many indexes $i \in \dom(\tau)$ such that $\tau$ is progressing in $i$.

\item
$\Pi$ satisfies \emph{the global trace condition} if 
for all infinite paths $\pi$ of $\Pi$,
there is some infinitely progressing trace $\tau$ of $\pi$.
A pre-proof for a judment $J$ that satisfies the global trace condition is called a \emph{proof} for $J$.
% $t$ satisfies the global trace condition if $t \in \WTyped$
% and for all infinite paths $\pi$ of $\Pi$,
% there is some infinitely progressing trace $\tau$ of $\pi$.

\item
$t \in \WTyped$ satifies the global trace condition if
its pre-proof $\Pi::\Gamma \vdash t :A$ is a proof.
$\GTC$ is the set of terms satisfying the global trace condition.

\item
  $\CTlambda = \GTC \cap \Reg$. 
\end{enumerate}
\end{definition}

The global trace condition is decidable in polynomial space in the number of
subterms of $t$, %counted up to isomorphism, 
because it is a particular case of the size change algorithm for program 
termination (\cite{SCT}, Theorem 4). 
But this is a worst case analysis: for instance, 
we know that the global trace condition for pre-proofs is decidable quite fast on realistic examples
(\cite{10.1007/978-3-642-35182-2_25, 10.1145/3018610.3018623, 10.1145/3632888, 10.1007/978-3-031-90643-5_18, 10.1145/3453483.3454087, Brotherston2020, Stratulat_2021}). 

Note that, for any $t\in\CTlambda$, the $n$-safe level of $t$ is finite for all $n \in \Nat$. 
Indeed, by the global trace condition any infinite path $\pi$ in $\Pi::\Gamma\vdash t:A$ for some 
$\Pi$ must have some infinitely progressing trace, therefore must pass through a $\cond$-rule
infinitely many times, hence more than $n$ times. Thus, no infinite path can be included in the
the $n$-safe level of any $t\in\CTlambda$.
This fact is technically important to show properties of terms in $\CTlambda$. 

%Another nice feature of the global trace condition is 
%that for $t \in \GTC$ we require that for any proof $\Pi::\Gamma \prove t:A$ 
%all infinite paths have some infinite progressing trace. This proof is 
%left-finite, because all leftmost paths from any subterm of $t$ 
%have no progress point and 
%therefore are finite.  We conclude that if $t \in \GTC \subseteq \WTyped$
%then we can assign a unique type to $t$ with a unique proof, which is left-
%finite.

\begin{remark}
We now explain the effect of splitting the typing rule for $\ap$ into $\apvar$ and $\apnotvar$.
%$\apvar$ corresponds to an $\eta$-expansion and it introduces a global variable name $x^T$
%for the first argument of $t$. 
%As we said, 
We need to consider apart the case $t(x)$ of application of $t$ to a variable
$x$, because in this case we will also check, using GTC, 
whether the first argument $x$ of $t$ is infinitely decreasing in any infinite 
computation. If this is the case, then no infinite computation exists. 
%$\apvar$ is like 
%a mark \quotationMarks{to be observed} for the argument $x$ of $t(x)$,
%it helps to automatically discover a part of the terminating functions.
%Remark that we introduced a unique \emph{term notation $\ap$} for application: 
%we write $\ap(t,u)$ no matter if $u$ is a variable or not, while we split 
%the typing rule for $\ap$ into two subcases. 
\end{remark}

We now give some examples of terms in $\CTlambda$. 

%18:05 03/06/2024

%\section{Examples of terms of $\CTlambda$}
%21:25 25/03/2025
%15:35 26/03/2025

\begin{example}[The sum map]\label{example-sum}
The term $\Sum$ given in Example~\ref{example-sum-first} was well-typed and regular.
The proof for $\ \vdash \Sum:\N \rightarrow \N \rightarrow \N$ in Figure~\ref{fig:sum-proof} 
has an unique infinite path
and there is an infinite trace (consists of the sequence of $\N$ passed through by arrows) 
following the path. 
The infinite trace goes through progressing points (the rule instances of $\cond$-rule)
infinite many times. Therefore it satisfies the global trace condition, and then $\Sum \in \CTlambda$. 

%% The first example is the sum map $\Sum$ that computes the sum up to an input numeral. 

%% \begin{example}
%% \label{example-sum}
%% The term $\Sum$ is the term such that $\Sum \sim \lambda x.\cond(x,\lambda y.\Succ(\Sum(x)(y)))$.
%% We have $\Sum\in\Reg$ because it has finitely many subterms up to isomorphism: 
%% \begin{center}
%%   $\Sum$,
%%   \quad
%%   $\cond(x,\lambda y.\Succ(\Sum(x)(y)))$,
%%   \quad
%%   $x$,
%%   \quad
%%   $\lambda y.\Succ(\Sum(x)(y))$,
%%  \quad
%%   $\Succ(\Sum(x)(y))$,
%%   \quad
%%   $\Sum(x)(y)$,
%%   \quad
%%   $\Sum(x)$,
%%   \quad
%%    y
%% \end{center}
%% It is well-typed by the following derivation.\footnote{Remark that without the 
%% $\weak$-rule, the context of the top $\golddagger$ would be $x^\N, y^\N$ 
%% while the context of the bottom $\golddagger$ would be $\emptyset$. 
%% Without the $\weak$-rule, this particular proof would not be correct.}
%% \[
%% \infer[\lambda]{
%%   \vdash \Sum:\N, 
%%   \goldN 
%%   \rightarrow \N 
%%    \quad (\golddagger)
%% }{
%%   \infer[\cond]{
%%     x : \N \vdash 
%%     \cond(x,\lambda y.\Succ(\Sum(x)(y))): \goldN \rightarrow \N
%%      \quad (\goldspadesuit)
%%   }{
%%     \infer[\var]{
%%       x : \N \vdash x : \N
%%     }{}
%%     &
%%     \infer[\lambda]{
%%       x:\N \vdash \lambda y.\Succ(\Sum(x)(y)): \goldN \rightarrow \N  
%%       %\quad (\goldspadesuit)
%%     }{
%%       \infer[\Succ]{
%%         x:\N, y : \goldN 
%%         \vdash \Succ(\Sum(x)(y)): \N  
%%         % \quad (\goldspadesuit)
%%       }{
%%         \infer[\apvar]{
%%           x:\N, y : \goldN 
%%           \vdash \Sum(x)(y): \N
%%         }{
%%           \infer[\apvar]{
%%             x:\N,  y : \N
%%             \vdash \Sum(x): \goldN \rightarrow \N
%%           }{
%%             \infer[\weak]{
%%               x:\N,  y : \N
%%               \vdash \Sum: \N, \goldN \rightarrow  \N
%%             }{
%%               \infer*{\vdash \Sum: \N, \goldN \rightarrow \N 
%%                 \quad (\golddagger)}{}
%%             }
%%           }
%%         }
%%       }
%%     }
%%   }
%% }
%% \]
%% In a computation we can represent this infinite tree by a finite cyclic graph
%% by adding a back edge from the  $\golddagger$ at the top to the $\golddagger$ at the bottom. 
\end{example}

%
%\begin{tikzpicture}
%  %\draw [help lines] (-3,-1) grid (9,7);
%  \coordinate (a) at (0,0) node at (a) {A};
%  \coordinate (c) at (0,5) node at (c) {C};
%  \draw (0,0) -- (0:2cm);
%  \draw (0,0) -- (30:3cm);
%  \draw (0,5) -- +(0:2cm);
%\end{tikzpicture}

\begin{example}[The recursor]\label{example:recursor}

We define the term $\Rec(a,f):\N\rightarrow A$ for $a:A$ and $f:A,\N \rightarrow A$
that is the recursor for $a$ and $f$, namely
it computes
\begin{center}
  $\Rec(a,f)(0) \reduces a$ \quad and \quad $\Rec(a,f)(\Succ(t)) \reduces f(\Rec(a,f)t)(t)$.
\end{center}
We abbreviate $r = \Rec(a,f)$. $r$ is defined by the equation $r = \cond(a,\lambda x.f(r(x))(x))$.
Note that $r$ is regular and is in $\GTC$ by the following proof with $\Gamma=(f:A,\N \rightarrow A,a:A)$.
The arrows specifies the unique infinitely progressing trace of the unique infinite path repeating from $(\dagger)$ on the bottom to
$(\dagger)$ on the top. 
If we want a finite cyclic graph notation we add a back edge between the judgments with $(\dagger)$ signs. 
The red arrow is the progress point, which is cyclically repeated in the infinite trace.
Hence $\Rec(a,f) \in \CTlambda$.
\begin{figure}[t]
\begin{prooftree}
  \AxiomC{}
  \RightLabel{$\var$}
  \UnaryInfC{$\Gamma \vdash a:A$}
  \AxiomC{}
  \RightLabel{$\var$}  
  \UnaryInfC{$\Gamma,x:\N \vdash f: A \rightarrow \N \rightarrow A$}
  \AxiomC{$\vdots$}
  \noLine
  \UnaryInfC{$\Gamma \vdash r:\vnode7{\N}\rightarrow A$
   \quad $(\vnode8{\dagger})$}
  \RightLabel{$\weak$}  
  \UnaryInfC{$\Gamma,x:\N \vdash r:\vnode6{\N}\rightarrow A$}
  \RightLabel{$\apvar$}  
  \UnaryInfC{$\Gamma,x:\vnode5{\N} \vdash r(x):A$}
  \BinaryInfC{$\Gamma,x:\vnode4{\N} \vdash f(r(x)):\N \rightarrow A$}
  \RightLabel{$\apvar$}
  \UnaryInfC{$\Gamma,x:\vnode3{\N} \vdash f(r(x))(x):A$}
  \RightLabel{$\apnotvar$}
  \UnaryInfC{$\Gamma \vdash \lambda x.f(r(x))(x):\vnode2{\N} \rightarrow A$}
  \RightLabel{$\cond$}
  \BinaryInfC{$\Gamma \vdash r: \vnode1{\N} \rightarrow A$
  \quad $(\vnode0{\dagger})$}
\end{prooftree}
$
\dirflowrededges{node1/node2}
\dirflowedges{node2/node3}
\dirflowedges{node3/node4}
\dirflowedges{node4/node5}
\dirflowedges{node5/node6}
\dirflowedges{node6/node7}
\bentflowblackedges{node8/node0/60}
$    
\caption{Typing of $\Rec$}\label{fig:rec-proof}
\end{figure}

Note that $\CTlambda$ contains G\"{o}del's $\systemT$ since it has expressive power of the numerals and the recursor. 
Moreover the computational properties of $\Rec(a,f)$ displayed in the figure \ref{fig:rec-proof} 
are realized using the $0$-safe-reductions only. 
\end{example}  



